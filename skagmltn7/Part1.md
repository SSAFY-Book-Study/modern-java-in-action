<h1>Part1. 기초</h1>
<br>

초반에 자바가 주요언어로 자리잡을 수 있었던 이유<br>

- 유용한 라이브러리를 포함한 `객체지향` 언어
- 스레드와 락을 사용한 `동시성` 지원
- `JVM 컴파일링 방식` + `가상 머신 코드` 지원 -> 인터넷 애플릿 프로그램의 주요 언어로 자리잡음.<br>

<br>
그러나 빅데이터의 등장으로 병렬 프로세싱의 필요성에 자바는 변화할 필요가 생김.<br>
그 해결책으로 자바8부터는 다음과 같은 기능을 제공.<br><br>

- **스트림 API** <br>
- **동작 파라미터화(메서드 전달 및 람다)**<br>
- **병렬성과 공유 가변 데이터**<br>

<br>

<h2> 1. 스트림API </h2>

- 입력 스트림으로 하나의 파이프라인을 만들어 중간 연산 스트림을 순차적으로 처리 후 최종연산 반환.
  `(여러 개의 중간 연산 + 하나의 최종연산)`
  <br>

  > 어떤 프로그램의 출력 스트림은 다른 스트림의 입력 스트림이 될 수 있음.<br>

- 한번에 한 항목을 처리하던 기존 자바와 달리 일련의 스트림으로 처리하기 때문에 `여러 CPU 코어 할당 가능`

- 스레드를 사용하지 않아도 `병렬성` 사용 가능

컬렉션으로 데이터를 처리하면서 나타는 `1.모호함과 반복적인 코드 문제, 2. 멀티코어 활용 어려움` 해결<br>

<h3>내부반복</h3>

- 외부 반복<br>
  **컬렉션**에서는 for - each루프를 통해 각 데이터에 접근하여 반복과정을 직접 처리하는 방식<br>

- 내부 반복<br>
  **스트림**에서는 라이브러리의 내부적으로 모든 데이터가 처리됨

  <br>

<h3>포킹단계</h3>

1. 두 개의 CPU 환경에서 하나의 리스트를 처리하는 경우, 하나는 앞 부분, 하나는 뒷 부분을 요청하는 단계.<br>

2. 각 CPU는 맡은 부분을 처리<br>

3. 하나의 CPU가 두 결과 정리<br>

> **포크 -> 처리(필터) -> 머지**

<br>

<h2> 2. 동작 파라미터화 </h2>
어떻게 실행할지 결정되는 않은 코드 블록<br>

- `메서드의 내용을 다른 메서드의 매개변수`로 넘겨줌.<br>
  이를 통해, 스트림 API가 하나의 파이프라인에 적용할 수 있게 함.

> 같은 동작을 수행하지만 사용하는 도구나 조건이 달라지는 경우 `동작 파라미터화`를 사용하면 함수의 재사용성을 높일 수 있음.

**사용방법**

- 람다(익명 객체) 사용 -> 코드의 간결성, 유연성 증가<br>
- 함수형 인터페이스 사용<br>
  <br>
  <br>

<h2> 3. 병렬성과 공유 가변 데이터</h2>

여러 스레드가 동시에 같은 데이터를 사용하면 속도차에 따라 데이터의 가변상태가 다를 수 있음. 그래서 스레드에서는 `synchronized`를 사용함.<br>

스트림을 통해 병렬성을 사용하기 위해서는 `stateless`한 함수로, 공유 가변 데이터에 접근하지 않아야함.
<br>
<br>

<h2> 4. 메서드 참조와 람다</h2>

- **일급시민**: 프로그램에서는 함수를 통해 기본값(int, double 등), 참조값(String, 배열 등)을 바꿈. <br>
- **이급시민**: `클래스, 메서드`는 값의 구조를 효과적으로 보여줄 뿐 `자유롭게 전달 할 수 없음`.
  <br>

<h3>이급시민을 일급시민으로 바꾸는 기능</h4>

> 메서드를 값으로 취급할 수 있도록 하는 기능

<br>

<h3>4.1 메서드 참조</h3>

|                유형                |        예시         |        표현방식        |
| :--------------------------------: | :-----------------: | :--------------------: |
|        **정적 메서드 참조**        | Integer :: parseInt | 클래스이름 :: 메서드명 |
|      **인스턴스 메서드 참조**      |  String :: length   | 클래스이름 :: 메서드명 |
| **특정 객체 인스턴스 메서드 참조** |  this :: 메서드명   | 참조변수명 :: 메서드명 |
|          **생성자 참조**           |    String :: new    |   클래스이름 :: new    |

> 메서드 명을 명시적으로 참조하여 `가독성` 높임

<br>

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
  public boolean accept(File file) {
    return file.isHidden(); // 숨겨진 파일 필터링
  }
});

==

File[] hiddenFiles = new File(".").listFiles(File :: isHidden);
```

<br>
<h3>4.2 람다: 익명 함수</h3>

한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없음. <br>

하지만 람다가 몇 줄 이상으로 길어진다면 따로 클래스를 선언 후 **메서드 참조**를 활용하는 것이 바람직함. <br>

> `코드의 명확성`이 우선시 되어야 한다.<br>

<h4>특징</h4>

- **익명** <br>
  : 이름이 없는 메소드로 구현할 코드가 줄어듬.

- **함수** <br>
  : 특정 클래스에 종속되지 않고 메서드의 멤버를 모두 가질 수 있음<br>

- **전달** <br>
  : 동작 파라미터화하거나 변수로 저장 가능<br>

- **간결성**<br>
  : (파라미터) -> {바디} 로 구성되어 있음
  <br>

<h4>문법</h4>

```java
(parameters) -> expression 	//표현식 스타일
(parameters) -> { statements; } // 블록 스타일


(List<String> list) -> list.isEmpty() // 불리언 표현식

() -> new Apple(10) // 객체 생성

(Apple a) -> { System.out.println(a.getWeight()); } // 객체에서 소비

(String s) -> s.length() // 객체에서 선택/ 추출

(int a, int b) -> a * b // 두 값 조합

(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()) // 두 객체 비교
```

<h4> 함수형 인터페이스 </h4>

: 디폴트 메서드를 제외하고 `1개의 추상메서드`만 가진 인터페이스, 어노테이션 `@Functionalinterface`를 통해 컴파일 체크를 할 수 있음

<h5>함수 디스크립터</h5>

java.uitl.function 패키지의 `Predicate, Consumer, Function` 등 함수형 인터페이스의 추상 메서드 시그니처

- 기본형 특화 (**IntPredicate, LongBinaryOperator** 등)<br>
  제네릭으로는 참조형밖에 선언할 수 없음 -> 비용 소모(`오토박싱 + 힙 메모리에 저장된 기본형의 값 탐색과정`)를 줄이기 우해 `기본형 특화 함수 디스크립터` 사용<br>

<br>

<h4> 컴파일러에서 람다를 체크하는 방식</h4>

1. 람다의 컨텍스트를 통해 `형식 추론`<br>
2. `대상 형식`을 통해 람다 표현식과 함수 디스크립터 매칭<br>

<h4>자유변수와 람다 캡처링</h4>

- **람다 캡처링**<br>
  자유변수를 람다에서 사용할 수 있게 함<br>

- **자유변수**<br>
  람다 바디 안에서 선언된 변수가 아닌 `외부에 선언된 지역 변수`, final로 선언되어 있거나 선언 후 수정되지 않아야함.

  - why?<br>
    - 지역변수는 `스택 메모리`에 저장되고 인스턴스 변수는 `힙 메모리`에 저장<br>
    - 람다에서 사용중에 지역 변수를 할당한 스레드가 사라지면 람다에서 접근 할 수 없음.
    - 따라서 람다는 지역 변수의 복사본을 제공받아 사용하고 이러한 제약으로 복사본의 값은 바뀌지 않아야함<br>

<h2> 5. 디폴트 메서드와 자바 모듈 </h2>

<h3>배경</h3>
`외부의 컴포넌트`를 처리해야하는 필요성 대두<br>
인터페이스를 구현하는 모든 클래스의 구현을 바꿔야함 <br>

<h3>해결 방안</h3>

- 자바9에서는 `자바모듈` 제공<br>
  모듈을 정의하는 문법을 제공 -> 패키지 모음을 포함하는 모듈 정의 가능<br>

- 자바8부터 `디폴트 메서드` 제공<br>
  디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 `미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공`하는 기능<br>

  - 인터페이스에 새로운 메소드가 추가되면 그 인터페이스를 구현하는 모든 클래스에서 메소드를 추가 구현해야하는 `번거로움 해결`<br>

<h2> 6. Opiontal</h2>
NullPointer예외를 피할 수 있게 도와주는 클래스<br>
