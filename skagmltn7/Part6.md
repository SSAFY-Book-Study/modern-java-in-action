<h1>함수형 프로그래밍과 자바 진화의 미래</h1>
<h2>1. 함수형 관점으로 생각하기</h2>
<h3>공유된 가변 데이터</h3>

`시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신`하기 때문에 **변수가 예상하지 못하는 값을 갖음**<br>
어떤 자료구조도 바꾸지 않는 시스템이 있다면 문제가 일어날 일이 없기때문에 유지보수가 쉬움

- **순수(pure) 메서드 또는 부작용 없는(side-effect free) 메서드**<br>
  : 자신을 포함하는 클래스의 상태, 타 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드

  - 부작용
    - 자료구조를 고치거나 필드에 값을 할당(setter)
    - 예외 발생
    - 파일에 쓰기 등의 I/O 동작 수행

  <br>

- 명령형 프로그래밍<br>
  - `어떻게`에 집중하는 프로그래밍 형식
- 선언형 프로그래밍<br>
  - `무엇을`에 집중하는 프로그래밍 형식
  - 질의문 자체로 문제를 푸는 방식을 보여줌(**내부반복**)
- 함수형 프로그래밍<br>
  - 선언형 프로그래밍을 따름
  - 부작용없는 계산을 지향

<h3>함수형 프로그래밍</h3>

- *함수*를 이용하는 프로그래밍

  - 여기서의 함수는 수학적인 함수와 같음
  - 함수는 0개 이상의 인수를 가지며 한 개 이상의 결과를 반환하지만 부작용이 없어야 함

- 수학적인 함수인지에 따라 함수와 메서드로 구분됨
- 시스템의 다른 부분에 영향을 미치지 않아야 함(**참조 투명성**)
- 인수가 같을 경우, 수학적 함수를 반복적으로 호출했을 때 항상 같은 결과가 반환되어야함
  <br>

<h4>함수형 자바</h4>

- 함수형 자바 프로그래밍은 자바에서 완벽한 순수 함수형 프로그래밍을 구현하기는 어렵지만, 코드를 작성하여 시스템의 컴포넌트가 순수한 함수처럼 동작하도록 할 수 있음
- 자바에서 구현할 수 있는 것은 순수 함수형이 아니라 함수형 프로그래밍. 이는 실제로 부작용이 있을 수 있지만, 이를 외부에서 감지할 수 없도록 하는 방식으로 함수형 프로그래밍의 이점을 살릴 수 있음

- 지역 변수 변경

  - 함수나 메서드는 지역 변수만을 변경
  - 외부 변수나 상태를 변경하면 함수형 프로그래밍의 원칙에 어긋남

- 불변 객체 사용

  - 함수나 메서드가 참조하는 객체는 불변객체

- 예외 처리
  - 함수형 프로그래밍에서는 함수나 메서드가 어떤 예외도 일으키지 않아야 함
  - 예외가 발생하는 경우, `Optional<T>`나 기타 방법을 사용하여 연산의 수행 여부를 확인

<h4>참조 투명성</h4>

- `부작용을 감춰야한다`제약으로 귀결
- 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환해야 `참조적으로 투명한 함수`라 표현
- 프로그램 이해에 큰 도움을 준다.
- 오래 걸리는 연산에 대해 `기억화(memorization) / 캐싱(caching)`을 통해 최적화

<h4>재귀와 반복</h4>

- 함수형 프로그래밍에서는 가변 상태를 피하고 불변성을 유지하기 위해 반복문 대신 재귀를 사용
  - 루프 내부에서 공유하는 데이터의 상태를 변화시킬 수 있기 때문
- 재귀 호출의 많은 메모리 사용 문제는 `꼬리 재귀 최적화(tail-call optimization, CTO)`를 통해 해결
  - CTO는 컴파일 시 하나의 스택 프레임으로 재활용하하는 최적화로 속도 손실X

<h2>함수형 프로그래밍 기법</h2>

<h3>고차원 함수</h3>

- 함수를 인수로 받아서 다른 함수로 반환하는 정적 메서드
- 고차원 함수를 적용할 때 어떤 인수가 전달될지 알 수 없으므로 인수로 전달된 함수가 어떤 부작용을 포함할지 문서화 권장

<h3>커링</h3>

- 함수를 모듈화하고 기존 변환로직을 재활용할 수 있도록 하는 기법
  - x와 y라는 두 인수를 받는 함수 f를 한개의 인수로 받는 g라는 함수로 대체하는 기법`f(x,y) = (g(x))(y)`
  - 함수 g의 상태는 여러과정이 끝나지 않은 상태이므로 '함수가 부분적으로(partially) 적용되었다'

<h3>영속 자료구조</h3>

- 저장된 값이 다른 누군가에 의해 영향을 받지 않는 상태의 자료구조
- 계산 결과를 표현할 자료구조가 필요하면 기존 자료구조를 갱신하지 않도록 새로운 자료구조를 만들어야 함.

<h3>스트림과 게으른 평가</h3>
<h4>스트림의 자기참조</h4>

- 스트림은 일회용이기 때문에 재귀적으로 자신을 정의할 수 없음

<h4>게으른 평가</h4>

- 스트림에서는 스트림의 인자가 함수이기 때문에 최종 연산전까지 수행되지 않음
- 자바 8이후 함수가 일급 시민이되면서 함수를 자료구조 내부로 추가할 수 있음 -> 자료구조를 만드는 시점이 아니라 `요청 시점에 실행`됨
- `Supplier()`를 호출하여 게으른 자료구조 생성

<h2>스칼라 소개</h2>

- **자바와 스칼라의 공통점**
  - 객체지향과 함수형 프로그래밍 스타일을 지원하는 프로그래밍 언어
  - 둘 다 JVM(Java Virtual Machine)에서 실행되며 상호운용성을 제공
- **스칼라**
  - 자바의 기본 컬렉션 외에도 리스트, 집합, 맵, 스트림, 옵션과 같은 추상 컬렉션뿐만 아니라 튜플과 같은 추가적인 자료구조를 제공
  - 함수 형식, 클로저(지역 변수에 접근 가능한 익명 함수), 내장 커링 형식과 같은 고급 함수 기능을 제공
  - 스칼라의 클래스는 암묵적으로 생성자(constructor), 게터(getter), 세터(setter)를 제공하여 더 간결한 코드 작성 가능
  - 트레이트(trait)라는 개념을 지원
    - 트레이트는 필드와 디폴트 메서드를 포함할 수 있는 인터페이스로, 코드의 재사용성을 높이고 다중 상속을 지원

<h2>결론 그리고 자바의 미래</h2>
<h3>자바 8의 기능 리뷰</h3>
<h4>동작 파라미터화</h4>

- 동작 파라미터화를 위해 람다와 메서드 참조를 제공
- 자바8이전에는 필터링 조건을 메서드 내에 클래스로 감싼 후 해당 클래스의 인스턴스를 전달하는 복잡한 방법을 사용했지만, 자바 8에서는 간단한 방식으로 코드 블록 전달
  - 람다 표현식이나 메서드 참조를 Function<T, R>, Predicate<T>, BiFunction<T, U, R> 등과 같은 형식으로 전달
- 이러한 기능은 자바 8의 새로운 스트림 API에서 람다를 사용하여 강력한 기능 제공
- 간결한 코드 작성과 자바의 핵심 기능을 효과적으로 활용을 가능케함

<h4>스트림</h4>

- 자바 8 설계자는 기존의 컬렉션 클래스, 반복자, for-each 구문에서 발생하는 문제를 해결하고자 스트림 API를 도입
  - 대규모 컬렉션에 여러 연산을 적용할 때 문제가 있었는데, 기존 방식에서는 `세 번의 탐색`이 필요
  - 필드 매핑, 조건 필터링, 결과 정렬하는 각각의 단계에서 컬렉션 재탐색
  - 스트림 API는 이러한 연산을 파이프라인으로 구성하고, 게으른 형식의 연산을 사용하여 `한 번의 탐색으로 모든 연산을 수행`
  - 큰 데이터 집합에서도 효율적인 데이터 처리 가능
- 대규모 데이터 집합에서도 효율적인 데이터 처리를 가능케 하며, 멀티코어 CPU를 활용한 병렬 처리 지원
- 이러한 스트림 API의 아이디어와 개념은 CompletableFuture의 설계에도 적용되어, 부작용이 없는 연산, 람다, 메서드 참조 등이 핵심적인 구성 요소로 활용

<h4>CompletableFuture 클래스</h4>

- Future 인터페이스는 여러 작업을 동시에 실행할 수 있도록 스레드나 코어를 할당
- 결과가 필요할 때 get 메서드를 통해 결과를 기다림
- 자바 8에서는 람다 표현식을 사용하여 Future와 관련된 공통 디자인 패턴을 간결하게 표현할 수 있는 CompletableFuture 클래스가 등장
- 스트림과 컬렉션과 같이 파이프라인 연산을 구성하여 명령형 프로그래밍에서 발생하는 불필요한 코드를 피함

<h4>Optional 클래스</h4>

- 형식의 값을 반환하거나 값이 없음을 의미하는 Optional.empty 메서드를 제공
- NullPointerException을 방지
- 프로그램의 이해와 문서화를 용이

<h4>Flow API</h4>

- 리액티브 스트림과 리액티브 당김 기반 역압력 프로토콜을 표준화한 Flow API를 도입
- 빠른 생산자와 소비자 간의 효과적인 통신을 가능케 함

<h4>디폴트 메서드</h4>

- 인터페이스에 추가할 수 있게 되어 라이브러리 설계자들이 새로운 기능을 추가할 때 기존 인터페이스를 구현하는 클래스가 모두 해당 기능을 구현하지 않아되기 때문에 라이브러리 설계 용이함
- 개별 프로그래밍의 구현에 영향을 미치지 않음

<h3>자바 9 모듈 시스템</h3>

- 새 기능은 추가되지 않음
- 새 모듈 시스템인 modul-info.java파일 추가
- 기존 호환성을 일부 희생하여 애플리케이션의 모듈화를 통해 코드의 구조를 명확히 하고 보안과 관련된 기능을 강화
- 자바 런타임을 세분화하여 필요한 부분만 사용하여 사물인터넷 어플리케이션과 클라우드 환경에서 자바를 사용할 때 중요한 역할을 함
- 자바 모듈시스템의 장점
  - 안정적 설정<br>
    : 모듈 요구사항을 명시적으로 선언함으로 의존성 빠짐, 충돌, 순환 등의 문제를 런타임이 아니라 빌드 과정에서 확인 가능
  - 강한 캡슐화<br>
    : 자바 모듈 시스템은 특정 패키지만 노출하여 각 모듈에서 공개할 부분과 내부 구현의 영역 접근 분리 가능
  - 보안성 개선<br>
    : 사용자가 모듈의 특정 부분을 사용할 수 없도록 함으로 보안성을 높임
  - 성능 개선<br>
    : 클래스가 런타임에 로드된 다른 클래스를 참조하는 상황보다는 적은 수의 컴포넌트를 참조할 때 최적화 기술 효과 발휘
  - 확장성<br>
    : 자바 모듈 시스템은 자바 SE 플랫폼을 세분화하여 실행중인 어플리케이션에서 필요한 부분만 사용 가능

<h3>자바 10 지역 변수형 추론</h3>

- 컨텍스트로 형식을 유추할 수 있는 상황에서는 제네릭의 형식 파라미터 생략 가능

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();

// 자바 7이후
Map<String, List<String>> myMap = new HashMap<>();
```

- 지역 변수형 추론(local variable type inference)이라 불리는 기능이 추가됨

```java
var myMap = new HashMap<String, List<String>>();
```

- var 키워드를 사용하여 지역 변수의 형식을 추론할 수 있게 되었으며, 초기화 코드가 없을 때는 var를 사용할 수 없다는 제약이 적용되어 형식 추론이 명확
- 코드 편집 작업을 줄이고 가독성을 향상시킴
- but 변수의 초기화에 따라 형식이 모호해질 수 있는 상황 주의
