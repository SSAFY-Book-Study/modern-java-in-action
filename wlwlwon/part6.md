# part6

### 18.1.1 공유된 가변 데이터

가변 데이터 구조를 공유하는 여러 메서드로 인해 예상치 못한 변수 값을 가질 수 있는 이유

이러한 상황에서는 어떤 클래스가 데이터를 소유하고, 한 클래스에서 데이터를 변경하면 다른 클래스가 이 변경 사실을 어떻게 알게 되는지에 대한 문제가 발생합니다. 이런 경우, 데이터를 소유한 클래스를 명확히 식별하기 어려울 수 있음

또한, 데이터 변경 사실을 추적하기 어렵다면 프로그램이 더 복잡해질 수 있으며, 이를 해결하기 위해 데이터를 공유하는 클래스 간의 협력 및 통신 방법을 고려해야함.

예를 들어, 데이터가 변경되었을 때 다른 클래스에 이를 알리는 메커니즘을 도입하거나, 데이터를 변경하지 않고 안전하게 데이터의 사본을 만드는 방법을 고려할 수 있음.

부작용이 없는 메서드를 사용하는 것도 고려할 가치가 있습니다. 부작용이 없는 메서드는 함수 내에서 다른 객체나 상태를 변경하지 않고, 결과를 반환하는 메서드를 의미하며, 이를 통해 코드를 예상치 못한 상태 변화로부터 보호하고 프로그램을 더 예측 가능하게 만들 수 있습니다.

또한, 불변 객체를 사용하여 데이터 변경을 방지하는 방법이 있음. 불변 객체는 한 번 생성되면 그 상태를 변경할 수 없는 객체로, 데이터 공유 및 스레드 안전성을 제공할 수 있습니다.

### 18.1.2 선언형 프로그래밍

```java
Optional<Transaction> mostExpensive =
 transactions.stream()
 .max(comparing(Transaction::getValue));
```

질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이  내부 반복 프로그래밍의 장점

‘무엇을’에 집중하는 방식을 선언형 프로그래밍이라고 함

### 18.1.3 왜 함수형 프로그래밍인가?

부작용이 없는 계산을 지향

람다 표현식을 이용해 작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는 데 많은 도움을 준다.

### 18.2 함수형 프로그래밍이란 무엇인가?

함수형 프로그래밍에서 함수란 수학적인 함수와 같다. 즉, 함수는 0개 이상의 인수를 가지며, 한개 이상의 결과를 반환하지만 부작용이 없어야한다.

자바와 같은 언어에서는 바로 수학적인 함수냐 아니냐가 메서드와 함수를 구분하는 핵심이다.

함수형이라는 말은 수학의 함수처럼 부작용이 없는을 의미

### 18.2.1 함수형 자바

자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다. 하지만 시스템의 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다. 자바에서는 순수 함수형이 아니라 함수형 프로그램을 구현할 것이다. 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 함수형을 달성할 수 있다.

함수나 메서드는 지역 변수만을 변경해야 함수형이라 할 수 있다. 그리고 함수나 메서드에서 참조하는 객체가 있다면 그 객체는 불변 객체여야한다. 즉, 객체의 모든 필드가 final이어야 하고 모든 참조 필드는 불변 객체를 직접 참조해야 한다.

### 18.2.2 참조 투명성

부작용을 감춰야 한다라는 제약은 참조 투명성 개념으로 귀결된다. 즉, 같은 인수로 함수를 호출 했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수라고 표현한다.

### 18.3 재귀와 반복

```java
static int factorialIterative(int n) {
 int r = 1;
 for (int i = 1; i <= n; i++) {
 r *= i;
 }
 return r;
}
//반복 방식
```

```java
static long factorialRecursive(long n) {
 return n == 1 ? 1 : n * factorialRecursive(n-1);
}
//재귀 방식
```

```java
static long factorialStreams(long n) {
 return LongStream.rangeClosed(1, n)
 .reduce(1, (long a, long b) -> a * b);
}
//스트림 팩토리얼
```

자바 8에서는 반복을 스트림으로 대체하여 변화를 피할 수 있다. 또한 반복을 재귀로 바꾸면 더 간결하고, 부작용이 없는 알고리즘을 만들 수 있다. 실제로 재귀를 이용하면 좀 더 쉽게 읽고, 쓰고, 이해할 수 있는 예제를 만들 수 있다.

### 19.1 함수는 모든 곳에 존재한다.

일반값처럼 취급할 수 있는 함수를 일급 함수라고 한다.

### 19.1.1 고차원 함수

- 하나 이상의 함수를 인수로 받음
- 함수를 결과로 반환

스트림 연산으로 전달하는 함수는 부작용이 없어야 하며, 부작용을 포함하는 함수를 사용하면 문제가 발생한다

### 19.1.2 커링

- 변환 요소
- 기준치 조정 요소

가 변환 결과를 좌우한다.

커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법이
다. 이때 g라는 함수 역시 하나의 인수를 받는 함수를 반환한다. 함수 g와 원래 함수 f가 최종적
으로 반환하는 값은 같다. 즉, f(x,y) = (g(x))(y)가 성립한다.

### 19.2.3 함수형 접근법 사용

```java
public static Tree fupdate(String k, int newval, Tree t) {
 return (t == null) ?
 new Tree(k, newval, null, null) :
 k.equals(t.key) ?
 new Tree(k, newval, t.left, t.right) :
 k.compareTo(t.key) < 0 ?
 new Tree(t.key, t.val, fupdate(k,newval, t.left), t.right) :
 new Tree(t.key, t.val, t.left, fupdate(k,newval, t.right));
}
```

### 19.3 스트림과 게으른 평가

스트림은 데이터 컬렉션을 처리하는 편리한 도구임을 살펴봤다. 효율적인 구현 및 여러 이유로
자바 8 설계자들은 스트림을 조금 특별한 방법으로 자바 8에 추가했다. 그중 하나로 스트림은
단 한 번만 소비할 수 있다는 제약이 있어서 스트림은 재귀적으로 정의할 수 없다. 이 절에서는
이와 같은 제약 때문에 어떤 문제가 발생하는지 살펴볼 것이다.

### 19.3.1 자기 정의 스트림

- 1 단계 : 스트림 숫자 얻기
    
    ```java
    static Intstream numbers() {
     return IntStream.iterate(2, n -> n + 1);
    }
    ```
    
- 2 단계 : 머리 획득
    
    ```java
    static int head(IntStream numbers) {
     return numbers.findFirst().getAsInt();
    }
    ```
    
- 3 단계: 꼬리 필터링
    
    ```java
    static IntStream tail(IntStream numbers) {
     return numbers.skip(1);
    }
    ```
    
- 4단계: 재귀적으로 소수 스트림 생성
    
    ```java
    static IntStream primes(IntStream numbers) {
     int head = head(numbers);
     return IntStream.concat(
     IntStream.of(head),
     primes(tail(numbers).filter(n -> n % head != 0))
     );
    }
    ```
    
    ### 기본적인 게으른 리스트
    
    3장에서 배운 Supplier<T>를 이용해서 게으른 리스트를 만들면 꼬리가 모두 메모리에 존재하지 않게 할 수 있다(Supplier<T>를 void -> T라는 함수형 디스크립터를 가진 팩토리로 생각할 수 있다). Supplier<T>로 리스트의 다음 노드를 생성할 것이다. 다음은 게으른 리스트를 만드는 코드다.
    
    ### 19.4.1 방문자 디자인 패턴
    
    자바에서는 방문자 디자인 패턴visitor design pattern으로 자료형을 언랩할 수 있다. 특히 특정 데이터
    형식을 ‘방문’하는 알고리즘을 캡슐화하는 클래스를 따로 만들 수 있다.
    
    ### 19.5.1 캐싱 또는 기억화
    
    참조 투명성이 유지되는 상황이라면 간단하게 추가 오버헤드를 피할 수 있는 방법이 생긴다. 표준적인 해결책으로 기억화memorization라는 기법이 있다.
    
    ### 20 자바와 스칼라 비교
    
    스칼라는 객체지향과 함수형 프로그래밍을 혼합한 언어다. 스칼라는 컬렉션을 함수형으로 처리하는 개념(스트림과 비슷한 연산), 일급 함수, 디폴트 메서드 등을 제공한다. 하지만 스칼라는 자바에 비해 더 다양하고 심화된 함수형 기능을 제공한다.
    
    ### 20.1 스칼라 소개
    
    ```java
    object Beer {
     def main(args: Array[String]) {
     var n : Int = 2
     while( n <= 6) {
     println(s"Hello ${n} bottles of beer") 
     n += 1
     }
     }
    }
    ```
    
    스칼라에서는 모든 것이 객체다. 자바와 달리 스칼라에는 기본형이 없다
    
    ### 20.1.2 기본 자료구조 : 리스트, 집합, 맵, 튜플, 스트림, 옵션
    
    지금까지 만든 컬렉션은 기본적으로 불변immutable이라는 점을 기억하자. 즉, 일단 컬렉션을 만들면 변경할 수 없다. 컬렉션이 불변이므로 프로그램에서 언제 컬렉션을 사용하든 항상 같은 요소를 갖게 되고 함수형 프로그래밍에서 유용하게 활용할 수 있다.
    
    ### 20.2.1 스칼라의 일급 함수
    
    스칼라의 함수는 일급값first-class value이다. 즉, Integer나 String처럼 함수를 인수로 전달하거나,결과로 반환하거나, 변수에 저장할 수 있다. 지금까지 살펴본 것처럼 자바의 메서드 참조와 람다 표현식도 일급 함수다
    
    ### 20.2.2 익명 함수와 클로저
    
    스칼라도 익명 함수anonymous function의 개념을 지원한다. 스칼라는 람다 표현식과 비슷한 문법을 제공한다.
    
    - 클로저
    - 3장에서는 자바의 람다 표현식이 클로저에 해당하는지 여부를 설명했다. 클로저closure란 함수의 비지역 변수를 자유롭게 참조할 수 있는 함수의 인스턴스를 가리킨다. 하지만 자바의 람다 표현식에는 람다가 정의된 메서드의 지역 변수를 고칠 수 없다는 제약이 있다. 이들 변수는 암시적으로 final로 취급된다. 즉, 람다는 변수가 아닌 값을 닫는다는 사실을 기억하자.
    
    ### 20.2.3 커링
    
    19장에서는 커링currying이라는 기법을 설명했다. x, y라는 두 인수를 가진 f라는 함수가 있을 때 이는 하나의 인수를 받는 g라는 함수 그리고 g라는 함수는 다시 나머지 인수를 받는 함수로 반환되는 상황으로 볼 수 있다는 것이다.
    
    ### 20.3 클래스와 트레이트
    
    이번에는 자바의 클래스와 인터페이스를 스칼라와 비교하자. 클래스와 인터페이스는 애플리케이션 설계의 핵심 요소다. 스칼라의 클래스와 인터페이스는 자바에 비해 더 유연함을 제공한다는 사실을 확인할 수 있다.
    
    ### 21.1 자바 8의 기능 리뷰
    
    - 한 가지 추세는 멀티코어 프로세서의 파워를 충분히 활용해야 한다는 것이다. 무어의 법칙에 따라 실리콘 기술이 발전하면서 개별 CPU 코어의 속도가 빨라지고 있다. 즉, 코드를 병렬로 실행해야 더 빠르게 코드를 실행할 수 있다.
    - 데이터 소스를 이용해서 주어진 조건과 일치하는 모든 데이터를 추출하고, 결과에 어떤
    연산을 적용하는 등 선언형으로 데이터를 처리하는 방식, 즉 간결하게 데이터 컬렉션을
    다루는 추세다. 간결하게 데이터 컬렉션을 처리하려면 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요하다.
    
    ### 21.4.3 풍부한 형식의 제네릭
    
    자바 5에서 제네릭을 소개했을 때 제네릭이 기존 JVM과 호환성을 유지해야 했다. 결과적으로ArrayList<String>이나 ArrayList<Integer> 모두 런타임 표현이 같게 되었다. 이를 제네릭
    다형성의 삭제 모델generic polymorphism erasure model이라고 한다. 이 때문에 약간의 런타임 비용을 지불하게 되었으며 제네릭 형식의 파라미터로 객체만 사용할 수 있게 되었다.
    
    만일 ArrayList<int>에서는 기본형 42를 얻을 수 있고, ArrayList<String>에서는 ‘abc’라는 문자열 객체를 얻을 수 있다면 왜 ArrayList 컨테이너를 구별할 수 있는지 여부를 걱정해야 할까? 불행하게도 가비지 컬렉션(GC) 때문이다. 
    
    런타임에 ArrayList의 콘텐츠 형식 정보를 확인할 수 없으므로 ArrayList의 13이라는 요소가
    Integer 참조인지(GC가 ‘사용 중in use’으로 표시) 아니면 int 기본값인지(GC 수행 불가) 분간할수 없다.
