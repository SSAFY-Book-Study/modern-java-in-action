# Part Ⅰ

# 1장. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

- 프로그래밍 언어는 생태계처럼 진화하지 않은 언어들은 도태되었지만, 자바는 경쟁 언어를 대신하며 커다란 생태계를 구축하였다.
- 자바 8은 **간결한 코드**, **멀티코어 프로세서의 쉬운 활용**이라는 두 가지 요구사항을 기반으로 새로운 기술을 제공한다.

---

## 자바 8의 3가지 프로그래밍 개념

### 1. 스트림 처리

- **스트림**이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
- 유닉스에서는 파이프(|)를 통해 복잡한 파이프라인을 구성하였지만, 자바에서는 많은 메서드를 제공하는 **스트림 API**를 통해 다양한 연산을 수행할 수 있음

### 2. 동작 파라미터화로 메서드에 코드 전달하기

- 메서드를 파라미터화하여 다른 메서드에 전달하는 기능

### 3. 병렬성과 공유 가변 데이터

- 기존에는 코드를 병렬 실행 시 (다중 프로세싱 코어, 스레드) 공유된 가변 데이터을 보호하기 위해 sychronized를 사용하였음
- **sychronized란**

메서드 앞에 sychronized를 선언하여 하나의 프로세스가 진행될 때 다른 프로세스가 간섭하지 못하게 해당 프로세스만을 진행하고 수행하도록 하는 기능(동기화)

- 자바 8에서는 스트림을 사용하여 쉽게 병렬성을 활용할 수 있음

---

## 자바 8에 추가된 기술

## 자바 함수

- 자바 8에서는 스트림과 연계될 수 있도록(병렬성을 위해) 함수를 새로운 값의 형식으로 추가함
- **일급 시민 :** int, double 등의 기본 값과 클래스의 인스턴스와 같이 런타임 동안 메서드에 전달할 수 있는 값
- **이급 시민** : 메서드에 전달할 수 없는 구조체인 메서드, 클래스 등과 같은 값
- 자바 8 이후에는 이러한 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가함

### 1. 메서드 참조

```java
// 디렉터리에서 모든 숨겨진 파일을 필터링하는 코드
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
public boolean accept(File file){
        return file.isHidden();
        }
        });
// 메서드 참조 활용(::)
        File[] hiddenFiles = new File(".").listFiles(File::isHidden); // File 클래스의 isHidden 메서드 참조
```

- (::) 메서드 참조를 이용하여 메서드의 파라미터에 직접 전달 할 수 있음

### 2. 람다 : 익명 함수

자바 8에서는 람다를 포함한 익명 함수 또한 일급 시민으로 취급함

**→ 람다(익명 함수)는 다른 메서드에 전달할 수 있음**

## 스트림

기존에 for-each 루프를 이용해서 컬렉션의 요소에 접근하는 **외부 반복**을 하였지만,

스트림 API를 사용하여 라이브러리 내부에서 모든 데이터를 처리하는 **내부 반복**을 함

### 멀티 스레딩

멀티 스레딩 시 기존에는 스레드 API(sychronized)를 사용하여 공유된 가변 데이터의 접근을 제어하여 Critical Section(임계 구역)문제를 해결했지만, 제어하기 힘들며 코드가 모호함

자바 8은 스트림API을 제공하여 해당 문제들을 모두 해결함

## 디폴트 메서드와 자바 모듈

인터페이스 내에서 **디폴트 메서드**를 통해 기존의 코드를 건드리지 않고 인터페이스 설계를 자유롭게 확장 가능함

## 함수형 프로그래밍에서 가져온 다른 유용한 아이디어

Optional<T> 클래스를 통해 NullPointer 예외를 피할 수 있음

- **Optional<T>**

값이 없는 상황을 어떻게 처리할 것인지 명시적으로 구현하는 메서드를 포함하는 컨테이너 객체

---

# 2장. 동작 파라미터화 코드 전달하기

- **동작 파라미터화**

어떻게 실행될 것인지 결정하지 않은 코드 블록이며, 나중에 프로그램에서 호출

- 변화하는 요구사항에 잘 대응할 수 있는 코드를 구현할 수 있음.
- 선택 조건을 결정하는 인터페이스 선언 후 클래스, 해당 인터페이스를 구현하는 익명 클래스, 람다 표현식을 사용함

### 동작 파라미터화 예시

- Collection 정렬(**알고리즘 시 많이 사용! ~~알아둘걸…~~**)

```java
// Comparator을 익명 클래스로 구현하여 inventory를 정렬(compare 추상 메서드)
inventory.sort(new Comparator<Apple>(){
public int compare(Apple a1, Apple a2){
        return a1.getWeight.compareTo(a2.getWeight));
        }
        });

// 람다 표현식으로 구현
inventort.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
```

---

# 3장. 람다 표현식

## 람다

익명 함수를 단순화 한 것으로, 익명 함수와 같이 이름이 없어 다른 메서드의 파라미터로 전달될 수 있음

---

### 람다의 표현식

```java
/* ( 람다 파라미터 ) -> 람다 바디 */
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());

// 1. 표현식 스타일 람다
// (파라미터) -> 표현식
// 람다 바디가 단일이면 {} 표기 생략 가능
// ex) (int x) -> x + 1

// 2. 블록 스타일
// (파라미터) -> {구문;}
// 명시적으로 return문을 사용하여 반환할 경우
// ex) (int x) -> {return x + 1;}
```

### 함수형 인터페이스

**추상 메서드**가 오직 **한 개**인 인터페이스이며, 람다 표현식으로 함수형 인터페이스의 추상 메서드를 구현하여 직접 전달하기 위해 사용

**→ 람다 표현식은 함수형 인터페이스의 인스턴스로 취급**

- **@FunctionalInterface**

함수형 인터페이스라는 것을 가리키는 어노테이션으로, 추상 메서드가 한 개가 아니라면 에러를 발생시키는 어노테이션

### 함수 디스크립터

함수형 인터페이스의 추상 메서드 시그니처를 **함수 디스크립터**라고 함

- **메서드 시그니처**

**메서드의 이름** + **메서드의 파라미터(매개 변수)** 이며 오버로딩 시 메서드의 차이 식별하기 위해 필요

```java
// Ex)
public String Hello(String name){
	return "Hello " + name;
}

// 위 메서드에서 메서드 시그니처는 Hello(String name)
```

## 함수형 인터페이스 사용

### 1. Predicate<T>

- test() 추상 메서드를 정의하며, 제너릭 형식 T의 객체를 받아 boolean으로 반환함
- (T) → boolean

### 2. Consumer<T>

- accept() 추상 메서드를 정의하며, 제너릭 형식 T의 객체를 받아 void를 반환(동작 수행)함
- (T) → void(동작)

### 3. Function<T, R>

- apply() 추상 메서드를 정의하며, 제너릭 형식의 T의 객체를 받아 R 객체를 반환함
- T → R

**예외처리**

- 예외를 던지는 람다 표현식을 만들 경우, 확인된 예외를 선언하는 함수형 인터페이스를 직접 정의하거나, 람다 표현식을 try~catch 블록으로 감싸야함

---

## 메서드 참조

- 메서드 참조를 통해 람다처럼 다른 메서드에 전달할 수 있음
- 람다에서 다른 메서드를 호출하는 것보다 메서드 참조를 통한 호출이 간결하여 가독성이 높음
- 메서드 앞에 구분자(::)를 붙이는 방식으로 메서드 참조 활용 가능

```java
// 람다와 메서드 참조의 차이 예제
// 람다의 경우
(Apple apple) -> apple.getWeight()
() -> Thread.currentThread().dumpStack()
(str, i) -> str.subString(i)

// 메서드 참조의 경우 (::)
Apple::getWeight // Apple 클래스의 getWeight 참조
Thread.currentThread::dumpStack
String::subString // String 클래스의 subString 메서드 참조
```
