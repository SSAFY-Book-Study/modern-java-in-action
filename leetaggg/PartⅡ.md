# 4장. 스트림 소개

---

## 스트림(Stream)

---

- **선언형**으로 데이터를 반복 처리를 할 수 있어 **유연성** 있는 프로그래밍 가능
- **가비지 변수(컨테이너 역할을 하는 중간 변수)** 를 사용하지 않고 데이터 처리 가능
- **고수준 빌딩 블록**으로 이루어진 연산 기능을 통해 데이터 처리 과정을 병렬화 할 수 있음

## 스트림의 특징

---

- 컬렉션의 stream 메서드를 통해 스트림을 얻을 수 있으며, 컬렉션과 같은 순서를 유지하며 스트림으로 변환됨
- 일반적인 연산과 데이터베이스와 비슷한 연산 2가지를 모두 지원함
- 스트림 연산끼리 연결하여 커다란 파이프라인을 구성하는 **파이프라이닝**을 하는 특징이 있음
- 반복자(Iterator)를 이용한 **외부 반복**이 아닌 **내부 반복**을 지원함

## 컬렉션과 스트림의 차이

---

**계산 시점의 차이**

- 컬렉션의 경우 컬렉션에 저장되기 전 모든 계산이 완료되어야함
- 스트림의 경우 요소를 요청할 때에만 요소를 계산함

**탐색 횟수의 차이**

- 컬렉션의 경우 반복 후 다시 반복을 하여 탐색하는 재활용이 가능
- 스트림의 경우 탐색 후 소비되어 다시 탐색을 하기 위해서는 스트림을 다시 생성해야함

**내부 반복과 외부 반복의 차이**

- 컬렉션의 경우 Iterator이나 for-each를 사용해서 요소를 반복하며, 병렬성을 스스로 관리해야함
- 스트림의 경우 라이브러리를 통해 내부적으로 요소를 반복하며, 병령성 구현을 자동으로 선택함

## 중간 연산과 최종 연산

---

### 중간 연산

- 스트림을 연산하여 다른 스트림을 반환함, 스트림과 스트림을 연결하는 파이프

### 최종 연산

- 스트림을 연산을 마치고 스트림 이외의 결과를 반환하여 스트림을 닫는 연산

---

## 스트림 연산의 3가지 특징

### 게으름(Lazy)

- 중간 연산은 최종 연산이 호출될 때 실행되는 특징

### 쇼트 서킷(Short Circuit)

- 게으름 특성으로 최종 연산 때 파이프라인 전체 구성을 보고 **최적화**된 실행을 하는 특징

### 루프 퓨전(Loop Fusion)

- 게으름 특성으로 filter, map 등의 여러개의 루프 연산 시 하나의 루프 연산으로 중간 연산을 수행하는 특징

### 게으름과 쇼트 서킷의 예시

```java
// 30, 40, 50, 60, 70, 80을 순회하여 100보다 작은 숫자 중 3개를 List로 반환하는 코드
List<Integer> numbers = IntStream.of(30, 40, 50, 60, 70, 80)
                                    .filter(nums -> {
                                        System.out.println("filtering: " + nums);
                                        return nums < 100;
                                    })
                                    .limit(3)
                                    .collect(toList());
```

```java
filtering: 30
filtering: 40
filtering: 50 
```

- 6개의 숫자는 모두 100보다 작지만 3개만 추출하는 limit(3) 메서드로 3번째로 100보다 작은 50을 추출하고 순회가 끊어짐
- 게으름 특성 덕분에 전체 파이프라인 연산을 보고 연산에 맞게 최적화를 실행함(쇼트 서킷)

# 5장. 스트림 활용

---

## 필터링

---

### filter()

- **프레디케이트(조건 함수)** 를 인수로 받아 조건에 부합하는 요소를 스트림으로 반환

### distinct()

- 스트림 요소 중 중복을 제거함

### takewhile()

- **프레디케이트**가 false일 경우 순회를 중단함
- 첫 요소 ~ 거짓인 요소 전 까지의 요소를 반환함

### dropwhile()

- **프레디케이트**가 false일 경우 순회를 중단함
- 첫 요소 ~ 거짓인 요소 전 까지의 요소를 버리고 이후 요소를 반환함

### limit()

- Integer를 인수로 받아 스트림 중 n개의 요소를 반환함
- 정렬 상태를 유지하여 반환함

### skip()

- Integer를 인수로 받아 처음 n개의 요소를 제외한 스트림을 반환함

---

## 매핑

---

### map()

- 함수를 인수로 받아 요소를 **매핑(변환)** 하여 새로운 형식의 요소로 변환함

```java
List<Integer> dishNameLengths = menu.stream()
				.map(Dish::getName) // Stream<String>
				.map(String::length) // Stream<Integer> 매핑됨
				.collect(toList());  // List<Integer>
```

### flatMap과 Arrays.stream()

- 모든 요소를 **단일 요소 스트림(가장 작은 단위의 단일 스트림)** 으로 반환함

## 리듀싱

---

### reduce()

- reduce(초깃값, BinaryOperator<T>)으로 사용함
- 모든 요소를 순회하여 요소가 하나일 때까지 반복
- 초깃값이 없으면 Optional<T> 객체를 반환함
- Integer::sum, max, min 등을 인자로 받을 수 있음

## 기본형 특화 스트림

---

- **기본형 특화 스트림**이란 숫자형 스트림을 효율적으로 처리할 수 있는 스트림
- IntStream, DoubleStream, LongStream이 있으며 mapToInt(), mapToDouble(), mapToLong 등으로 변환 가능
- boxed()를 통해 기본형 특화 스트림을 일반 스트림으로 변환

```java
int calories = menu.stream() // Stream<Dish>로 변환
                    .mapToInt(Dish::getCalories) // IntStream으로 변환
                    .sum(); // IntStream.sum() 연산 후 int로 변환
```

# 6장. 스트림으로 데이터 수집

---

## 컬렉터

---

### 컬렉터란?

- 스트림 요소를 어떤 식(형식)으로 도출할지 지정하는 것
- 기존의 명령형 프로그래밍(for문을 반복)보다 **간결하면서 유지 보수성이 높은 프로그래밍이 가능**

### 미리 정의된 컬렉터

- Collectors에서 제공하는 팩토리 메서드를 통해 사용 가능하며 3가지 기능을 제공
    - 스트림 요소를 하나의 값으로 리듀스하고 요약
    - 요소 그룹화
    - 요소 분할

# 컬렉터의 메서드

---

## 요약 연산

### Collectors.counting()

- 스트림 요소의 개수를 반환함

### Collectors.maxBy(), minBy()

- 스트림 요소 중 최댓값, 최솟값을 반환함
- 스트림 요소가 비어있을 수 있는 상황 때문에 Optional<T> 객체를 반환함

### Collectors.summing~, averaging~

- 스트림 요소의 합계, 평균을 제너릭 형식에 맞게 반환함

### Collectors.joining()

- 스트림의 각 객체의 모든 문자열을 하나의 문자열로 연결하여 반환

---

### 리듀싱과 컬렉터의 차이

- collect는 도출하는 결과를 **누적하는 컨테이너**로 바꾸는 메서드
- reduce는 도출한 두 값을 하나로 도출하는 **불변형 연산**
- 도출하는 결과가 가변성이 있으면 collect로 리듀싱 연산을 구현해야함

---

## 분류 함수 - groupingBy()

- SQL문과 같이 데이터 집합을 하나 이상의 특성으로 분류하여 그룹화 연산을 수행
- 인자로 받은 키 값에 따라 요소를 그룹화하여 분류하는 메서드

---

## 분할 함수 - partitioningBy()

- 프레디케이트를 기준으로 그룹화를 수행하며, 맵의 키 형식은 Boolean 타입이므로 2개의 그룹으로 나뉨

# 7장. 병렬 데이터 처리와 성능

---

## 병렬 스트림

- 컬렉션에서 parallelStream을 호출하면 병렬 스트림으로 생성됨

### parallel()

- 순차 스트림을 병렬로 리듀싱 연산을 수행
- sequential()을 통해 병렬 스트림을 순차 스트림으로 바꿀 수 있음
- parallel()과 sequential 중 최종적으로 호출된 메서드에 따라 처리 방법이 결정됨

### 청크

- 스트림에서 사용하는 **단일 데이터 조각**

---

### 병렬 처리의 잘못된 사용

**반복자(for문)과 parallel(병렬 처리)의 성능 차이**

```java
// 1부터 N까지 숫자의 합을 구하는 코드

public long iterativeSum(){ //for문 Loop
	long result = 0;
	for (long i = 1L; i <= N; i++{
		result += i;
	}
	return result;
}

public long parallelSum(){ // parallel 스트림 사용
	return Stream.iterate(1L, i -> i + 1)
				.limit(N)
				.parallel()
				.reduce(0L, Long::sum);
}

iterativSum() : 3.278 // for문 Loop 결과
parallelSum() : 604.059 // parallel 스트림 사용 결과
```

- 리듀싱 과정에서 숫자 리스트가 없어 스트림으로 병렬 처리를 수행할 수 없음

### 병렬 처리의 올바른 사용

- 기본형 특화 스트림을 사용하여 박싱과 언박싱 오버헤드를 줄임
- limit, findFirst처럼 요소의 순서에 의존하는 연산은 병렬 처리에 불리함
- 소량의 데이터에서는 병렬 처리로 얻는 이득보다 병렬화 과정에서 생기는 부가 비용이 더 큼
- 자료구조에 따라 병렬화 친밀도가 달라 병렬 처리 효율이 좋은 자료 구조에만 사용

---

## 포크/조인 프레임워크

- 재귀적인 작업을 병렬로 분할하여 처리하고 나뉘어진 결과를 하나로 합치는 프레임워크
- 분할한 결과(**서브태스크**)를 **스레드 풀**의 작업자 스레드에 분산 할당해야함

### 스레드 풀

작업 처리에 사용되는 스레드(**작업자 스레드**)를 제한된 개수만큼 정해놓고 작업 큐에 들어온 작업(**서브태스크**)을 하나씩 스레드가 맡아 처리함

### RcursiveTask<R>

- 스레드 풀을 사용하기 위해 만들어야하며, compute 추상 메서드를 구현해야함

### 작업 훔치기

- 스레드보다 많은 서브 태스크를 스레드에 공정하게 분할하게 하는 기법
- 각각의 스레드에게 할당된 태스크를 포함하는 이중 연결 리스트를 참조하게 하면서 태스크가 끝날 때마다 큐의 헤드에서 다른 태스크를 가져와 작업을 처리함
- 태스크를 최대한 작게 분할할수록 스레드 간의 작업 부하를 비슷하게 유지할 수 있음

## Spliterator

- 컬렉션을 탐색하는 iterator와 같은 동작을 하는 병렬 처리 인터페이스
- T는 탐색하는 요소의 형식
- trySplit을 통해 반환한 요소를 분할하고 다른 Spliterator를 생성하여 탐색 작업을 분할함
- trySplit의 결과가 null일 때까지 작업을 반복하며, null 일 시 재귀 분할 과정이 종료