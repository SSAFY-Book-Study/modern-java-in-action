# 18장. 함수형 관점으로 생각하기

---

## 공유된 가변 데이터

---

- **순수 메서드, 부작용 없는 메서드**

  → 클래스의 상태나 객체의 상태를 바꾸지 않고 결과를 반환하는 함수


- **부작용이란?**
  - 자료구조를 고치거나 필드에 값을 할당
  - 예외 발생
  - 파일에 I/O 동작 수행

  → 함수형 프로그래밍을 통해 해결


## 함수형 프로그래밍

---

- **함수형 : 수학적으로 부작용이 없는 것**
- 순수 함수형 프로그래밍 : 함수와 if-then-else 등의 수학적 표현만을 사용하는 방식
- 함수형 프로그래밍 : 시스템의 다른 부분에 영향을 미치지 않는 방식

- 실질적으로 I/O 모델 자체에 부작용이 있으므로 순수 함수형을 구현하기는 어려움

  → 부작용을 예외 처리 또는 Optional 처리하여 **함수형 프로그래밍**을 구현


## 재귀와 반복

---

- 순수 함수형 프로그래밍 언어에서는 반복문을 포함하지 않고, 재귀로 구현함

  → 반복으로 인해 변화가 생길 수 있기 때문

- 반복문보다 재귀가 더 많은 메모리를 사용하며, SOF를 발생

  → 컴파일러가 한의 스택 프레임을 재활용하는 **꼬리 호출 최적화**를 함수형 언어에서 지원함

- 자바에서는 반복문을 반복 스트림으로 대체하여 변화를 피함

# 19장. 함수형 프로그래밍 기법

---

- 인수로 전달, 결과로 반환, 자료구조에 저장하는 일반값처럼 사용할 수 있는 함수를 **일급 함수**라고 함

### 고차원 함수

- 한 함수가 하나 이상의 동작을 수행하는 함수

  → 자바 8의 함수는 고차원 함수

- 고차원 함수를 구현할 때에는 인수가 어떤 부작용을 포함할지 문서화하여 부작용 가능성을 염두해야함

### 커링

- x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법
- 변환 로직을 재활용하여 다양한 상황에 유연한 코드를 적용할 수 있음

### 영속 자료구조

- 함수형 프로그래밍에서는 불변하는 자료구조인 **영속 자료구조**를 사용함
- 자료구조를 갱신하면 결과가 달라지며 참조 투명성에 위배가 됨

  → 자료구조를 갱신하지 않고 새로운 자료구조를 생성함


**함수형으로 새로운 자료구조를 생성하지만, 인수를 이용해서 가능한 한 많은 정보를 공유함**

### 스트림과 게으른 평가

- 스트림은 최종 연산을 적용해서 표현식의 값이 필요한 시점에서 실제 연산이 이루어짐
- 전통적인(모든 값을 계산하는) 방법보다 여러 면에서 좋지만, 자료 구조의 데이터를 적게 사용하는 경우에는 게으른 실행으로 인한 오버헤드가 발생할 수 있음

### 캐싱, 기억화

- 메서드에 래퍼로 캐시를 추가하는 기법으로, 래퍼가 호출되면 캐시에 값이 존재하는지 확인 후 반환하고, 없을 시 결과를 계산 후 저장하고 반환함

### 콤비네이터

- 두 함수를 인수로 받아 다른 함수를 반환하는 함수 조합 기능을 **콤비네이터**라고 함

# 20장. OOP와 FP의 조화 : 자바와 스칼라 비교

---

- 스칼라는 객체지향과 함수형 프로그래밍을 혼합한 언어
- 자바에 비해 더 다양하고 심화된 함수형 기능을 제공

# 스칼라

---

```scala
object Beer {
	def main(args: Array[String]) {
		var n : Int = 2
		while( n <= 6) {
		println(s"Hello ${n} bottles of beer") <- 문자열 보간법
		n += 1
		}
	}
}
// 출력
Hello 2 bottles of beer
Hello 3 bottles of beer
Hello 4 bottles of beer
Hello 5 bottles of beer
Hello 6 bottles of beer
```

- println 인수 문자열에 접두어 s를 붙이면 문자열 자체에 변수와 표현식을 삽입할 수 있음
- 스칼라는 완전 객체지향 언어이므로 기본형이 없음

```scala
val numbers = Set(2, 5, 3); // 2, 5, 3을 가진 Set 객체 생성
val newNumbers = numbers + 8; // 새로운 Set 객체 생성
```

- 스칼라의 불변 자료구조에 요소를 추가하면 새로운 불변 자료구조 객체를 생성함

## 함수

---

스칼라의 함수는 어떤 작업을 수행하는 일련의 명령어 그룹으로 일급값이며, 3가지 기능을 제공함

1. **함수 형식** : 자바 함수 디스크립터의 개념
2. **익명 함수** : 람다 표현식과는 다르게 비지역 변수 기록에 제한을 받지 않음
3. **커링 지원** : 여러 인수를 받는 함수 → 일부 인수를 받는 여러 함수로 분리하는 기법

### 일급 함수

- 스칼라의 함수는 일급값이며, 함수를 인수로 전달하고나, 결과로 반환, 변수에 저장할 수 있음

```scala
def isJavaMentioned(tweet: String) : Boolean = tweet.contains("Java")
def isShortTweet(tweet: String) : Boolean = tweet.length() < 20

// filter에 함수를 전달함
val tweets = List(
	"I love the new features in Java 8",
	"How's it going?",
	"An SQL query walks into a bar, sees two tables and says 'Can I join you?'"
)
tweets.filter(isJavaMentioned).foreach(println)
tweets.filter(isShortTweet).foreach(println)
```

### 익명함수와 클로저

- 스칼라에서는 익명 함수의 개념을 지원하며, 자바의 내장 함수형 인터페이스처럼 트레이트를 지원함

```scala
Function<String, Boolean> isLongTweet = (String s) -> s.length() > 60;

isLongTweet("A very short tweet") // false를 반환함
```

- 스칼라의 익명 함수는 값이 아닌 변수를 캡쳐함

## 트레이트

---

### 클래스 VS 트레이트

- 스칼라에서는 생성자, 게터, 세터가 암시적으로 생성됨

```scala
class Student(var name: String, var id: Int) // Student 클래스
val s = new Student("Raoul", 1) // Student 객체 생성
s.id = 1337 // id 설정 (세터)
println(s.id) // 1337 출력 (게터)
```

### 인터페이스 VS 트레이트

- 트레이트도 추상 메서드와 기본 구현을 가진 메서드(디폴트 메서드)를 정의할 수 있음
- 트레이트는 다중 상속을 지원하며, 인스턴스화 과정에서도 조합할 수 있음

# 21장. 결론 그리고 자바의 미래

---

- 자바 8에서 큰 변화가 생긴 이유
  1. 개별 CPU 코어의 속도가 빨라짐에 따라 코드를 병렬로 실행해야 더 높은 성능으로 코드를 실행 할 수 있음
  2. 선언형으로 데이터를 처리하여 간결하게 데이터 컬렉션을 다루는 추세이며, 이를 위해서는 불변값을 생산할 수 있는 불변 객체와 불변 컬렉션이 필요

### 동작 파라미터화(람다와 메서드 참조)

- 함수형 프로그래밍을 지원하는 메서드를 람다나 메서드 참조로 전달할 수 있음

### 스트림

- 스트림 API는 컬렉션과 달리 하나의 탐색으로 연결된 파이프라인의 모든 연산을 수행하여 비교적 효율적인 데이터 처리가 가능함
- 스트림의 parallel 메서드로 스트림 연산을 병렬적으로 실행할 수 있음

### CompletableFuture 클래스

- CompletableFuture 클래스는 병렬 실행을 위해 작업을 각 스레드나 코어로 할당하는 Future 인터페이스를 구현한 클래스임
- Future와 관련한 공통 디자인 패턴을 명령형이 아닌 선언형으로 간결하게 표현하는 메서드를 제공함

### Optional 클래스

- Optional 클래스는 T 형식의 값을 반환하거나 값이 없음을 의미하는 클래스임
- null 값을 참조하는 것을 방지하여 NPE가 발생하지 않도록 하며, 스트림 클래스가 제공하는 것과 같이 다른 계산으로 연결하는 함수를 제공함

### 디폴트 메서드

- 자바 8 이전의 인터페이스는 메서드 시그니처(추상 메서드)만 정의했지만, 디폴트 메서드로 메서드의 기본 구현을 제공할 수 있음

### 모듈 시스템

- 자바 9에서 추가된 모듈 시스템으로 패키지간의 캡슐화를 강화했지만, 호환성이 저하됨
- 모듈 시스템의 장점 5가지
  - **안정적 설정** : 모듈 요구사항을 명시적으로 선언함으로 의존성 빠짐, 충돌, 순환 등의 문제를 런타임이 아니라 빌드 과정에서 일찍 확인할 수 있다
  - **강한 캡슐화** : 자바 모듈 시스템은 특정 패키지만 노출한 다음 각 모듈에서 공개할 부분
    과 내부 구현의 영역 접근을 분리할 수 있다
  - **보안성 개선** : 사용자가 모듈의 특정 부분을 사용할 수 없도록 함으로 해커가 보안 제어
    를 뚫기가 어려워졌다
  - **성능 개선** : 클래스가 런타임이 로드된 다른 클래스를 참조하는 상황보다는 적은 수의 컴
    포넌트를 참조할 때 최적화 기술이 더 효과를 발휘한다
  - **확장성** : 자바 모듈 시스템은 자바 SE 플랫폼을 작은 부분으로 나눔으로 실행중인 애플리
    케이션에서 필요한 부분만 사용할 수 있다


### 지역 변수형 추론

- 형식을 유추할 수 있는 상황에서는 제네릭의 형식 파라미터를 생략 가능

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();

// 할당문의 제네릭을 유추하여 생략 가능
Map<String, List<String>> myMap = new HashMap<>();
```

# 부록

---

### 어노테이션

- 부가 정보를 프로그램에 장식할 수 있는 기능으로 **문법적 메타데이터**임

  → 코드의 문서화, 컴파일러 경고, 실행 시 동작 변경, 런타임 검사 등 다양한 목적으로 활용

- 어노테이션은 중복 사용할 수 없지만, @Repeatable()으로 반복할 수 있는 어노테이션을 만들 수 있음

```java
@Repeatable(Authors.class)
@interface Author { String name(); }
@interface Authors {
	Author[] value();
}

// 어노테이션 반복 사용
@Author(name="Raoul") @Author(name="Mario") @Author(name="Alan")
class Book{ }
```

### 형식 추론

- 자바는 암시적으로 제네릭 인수를 추론함

```java
List<Car> cars = Collections.<Car>emptyList();

// 암시적 추론
List<Car> cars = Collections.emptyList();
```

### 맵

- **map.getOrDefault(”Key”, default 값)** : 맵에 키에 해당하느 값이 없으면 기본값을 반환
- map.computIfAbsent() : 값이 없을 시 Supply 함수 실행

### 컬렉션

- Collections.removeIf(Predict) : 프레디케이트와 일치하는 모든 요소를 제거

### 리스트

- List.replaceAll() :  리스트의 각 요소에 연산을 적용한 결과로 대체

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.replaceAll(x -> x * 2);
System.out.println(numbers); // [2, 4, 6, 8, 10] 출력
```

### 스트림 포킹

- 스트림에서는 연산을 한 번만 실행 가능함

  → 여러 번의 스트림 연산이 필요한 경우 스트림 포킹을 통해 병렬로 실행

- 스트림 포킹을 위해서는 StreamForker를 구현해야함

**StreamForker**

- fork(Key, Fucntion<Stream<T>, ?>) : StreamForker을 반환하는 함수
- getResults() : fork 메서드로 추가한 연산을 실행

### 익명 클래스

- 익명 클래스는 함수형 인터페이스를 구현할 수 있으므로 람다 표현식을 익명 클래스로 변환 가능

  → 컴파일러는 익명 클래스에 대응하는 새로운 클래스 파일을 생성하므로, 람다 표현식을 익명 클래스로 변환 시 각각의 클래스를 로드하고 검증하는 과정이 필요함

  → 애플리케이션 스타트업의 성능에 악영향을 미침

- Comparator를 표현하는 수백 개의 람다가 있다면 수백 가지의 Comparator의 서브형식이 생기므로 JVM이 런타임 성능을 개선하기 어려움
- 익명 클래스와 람다 표현식을 다른 바이트코드로 컴파일 됨

### 구원투수 InvokeDynamic

- JVM이 동적 형식 언어를 지원할 수 있도록 추가된 명령어로 더 깊은 수준의 재전송과 동적 언어에 의존하는 로직이 대상 호출을 결정할 수 있는 기능을 제공