# 15장. CompletableFuture와 리액티브 프로그래밍 컨셉의 기초

---

- 자바의 동시 프로그래밍은 Runnable과 Thread, ExecutorServies, RecursiveTask, 스트림과 람다, Future 등으로 진화함

## 스레드

---

- 단일 CPU의 경우 각 프로세스에 대해 CPU를 번갈아가며 할당하며 프로세스는 한 개 이상의 스레드에 할당 받은 CPU를 할당함
- 멀티코어의 경우 각 코어가 한 개 이상의 프로세스나 스레드에 할당함
- 외부 반복을 이용하여 명시적으로 스레드를 사용하는 것보다 병렬 스트림을 활용하여 스레드 사용 패턴을 추상화하는 것이 보다 높은 수준의 개념임

## 스레드 풀

---

### 스레드의 문제

- 자바 스레드는 운영체제 스레드에 **직접 접근함**
    
    → 운영체제 스레드 < 자바 스레드 = 어플리케이션 크래시가 일어남
    

**※ 크래시 : 컴퓨터 프로그램(응용 소프트웨어 또는 운영체제)이 적절하게 기능하는 것을 멈췄을 때이다.**

- 일반적으로 운영체제와 자바의 스레드 개수가 하드웨어 스레드보다 많으며, 하드웨어 스레드 개수는 하드웨어에 따라 다름

### 스레드 풀의 장점

- 자바는 ExecutroeService를 통해 워커 스레드를 직접 만들어 스레드 풀에 저장함
    
    → 스레드의 개수와 스레드 풀의 크기를 결정할 수 있음
    
- 하드웨어 수에 맞는 태스크를 유지하여 오버헤드 없이 태스크를 스레드에 할당할 수 있음

### 스레드 풀의 단점

- sleep()을 하거나 I/O를 기다리는 실행(블록)을 가진 태스크가 스레드에 할당 시 다른 스레드는 해당 태스크가 끝날 때까지 기다려야하는 상황이 생기며 병렬 처리에 효율이 떨어지며 데드락이 걸릴 수 도 있음
    
    → 블록할 수 있는 태스크는 스레드 풀에 제출하지 말아야하는데 이를 항상 지킬 수는 없음
    
- 프로그램을 종료하기 전에 모든 스레드 풀을 종료해야함
    
    → Thread.setDaemon을 통해 해결
    

### 스레드의 다른 추상화

- **엄격한 포크/조인** : 메서드가 호출되면 메서드 호출 내에 스레드 생성과 join()이 한 쌍처럼 중첩되어 작업이 끝나길 기다린 후 메서드가 종료됨
- **여유로운 포크/조인** : ****메서드가 호출되어 스레드가 생성되지만 메서드를 벗어나 스레드는 계속 실행됨 **(비동기 메서드)**
    - 여유로운 포크/조인(비동기 메서드) 시 문제점
        1. 스레드는 메서드 호출 뒤의 코드와 같이 실행되므로 데이터 경쟁 문제가 생김
        2.  실행되는 스레드가 종료되지 않은 상황에서 main() 메서드가 반환되는 문제가 생김

**문제 해결 방법**

- 종료하지 않고 모든 스레드가 실행이 끝날 때까지 기다림
- 스레드를 강제 종료 시키고 종료함
    
    → 애플리케이션이 크래시 될 수 있고, I/O 작업 중 중단 시 외부 데이터의 일관성이 파괴됨
    

**setDaemon()을 통해 데몬과 비데몬으로 스레드를 구분시켜 데몬일 경우 애플리케이션 종료 시 강제 종료되며, 비데몬일 경우 스레드 종료될 때까지 애플리케이션이 종료되지 않고 기다림**

## 동기 API와 비동기 API

---

## 동기 API

- 결과가 나올 때까지 물리적인 반환을 지연 시킴**(블로킹)**

```java
int f(int x);
int g(int x);

// Code1  메서드 호출 후 합계를 출력
int y = f(x);
int z = g(x);
System.out.println(y + z);

// Code2 Thread 사용
int x = 1337;
Result result = new Result();

Thread t1 = new Thread(() -> { result.left = f(x); } );
Thread t2 = new Thread(() -> { result.right = g(x); });
t1.start();
t2.start();
t1.join();
t2.join();
System.out.println(result.left + result.right);

private static class Result {
	private int left;
	private int right;
}
```

- Code1은 f(x)를 진행 후 g(x)가 끝나고 값을 반환
- Code2는 Thread를 사용하여 f(x)와 g(x) 중 더 오래 걸리는 작업을 기준으로 값을 반환
    
    **→ 명시적  반복(불필요한 코드)을 줄이고 내부 반복을 이용한 것처럼 코드를 변경해야함**
    

## 비동기 API

---

### Future 형식 API으로 변경

```java
Future<Integer> f(int x);
Future<Integer> g(int x);

Future<Integer> y = f(x);
Future<Integer> z = g(x);
System.out.println(y.get() + z.get());
```

- Future를 반환하여 get() 메서드로 Future의 결과가 완료되는 것을 기다림
- 둘 중 하나에만 Future을 적용할 수도 있지만 API 형식을 통일하고, 작고 합리적인 크기의 태스크로 나누는 것이 좋음

### 리액티브 형식 API로 변경

```java
// 콜백 형식
void f(int x, IntConsumer dealWithResult);
void g(int x, IntConsumer dealWithResult);

int x = 1337;
Result result = new Result();
 
f(x, (int y) -> {
	result.left = y;
	System.out.println((result.left + result.right));
});
g(x, (int z) -> {
	result.right = z;
	System.out.println((result.left + result.right));
});
```

- 메서드에 콜백 함수(람다)를 전달하여 결과가 준비되면 반환함
- 락이 없으므로 값이 2번 출력할 수 있고, 결과가 반환되기 전 업데이트 될 수 있음
    
    → if-then-else를 통해 콜백이 모두 호출된 후 반환
    
    → 리액티브 형식의 API는 일련의 이벤트에 반응하도록 설계되었기 떄문에 Future을 이용
    

## 잠자기

**sleep()** : 스레드를 잠시 **유휴 상태(멈추는 상태)**로 만듦

→ 스레드가 유휴 상태 중에도 자원을 소비하는 상황이 발생

- 스레드가 제한된 상황에서는 잠자는 태스크가 워커 스레드를 점유하지 못하도록 막아야함

## 비동기 API의 예외 처리

- 비동기 API에서 호출된 메서드는 별도의 스레드에서 실행되므로 호출한 실행 범위와 관계가 없어짐
    
    → 그래도 예상치 못한 상황에서는 예외를 발생시켜 다른 동작을 실행시켜야함
    
- 리액티브 형식은 return 대신 기존 콜백이 호출되므로, 예외 발생 시에 실행 시킬 콜백을 따로 구현해야함

```java
// void f(인수, 콜백 함수, 예외를 던지는 콜백 함수)
void f(int x, Consumer<Integer> dealWithResult, Consumer<Throwable> dealWithException))
```

### 박스와 채널 모델

- 동시성 모델을 설계하고 개념화하기 위해 모델이며 프로세스 간 통신 및 동기화에 관련된 작업을 모델링하고 설명함
- 박스란 독립적으로 실행되는 프로세스나 스레드이며, 채널은 박스 간의 통신을 담당하는 매개체

## 발행-구독 모델

- Future와 CompletableFuture의 경우 한 번만 실행하여 결과를 반환하지만, 리액티브 프로그래밍은 한 번의 결과가 아닌 여러 번의 결과가 필요함
    
    → 발행-구독 모델을 적용하여 해결
    
- 비동기적으로 발행자가 계속 이벤트를 생성하며, 이를 여러 구독자가 각각의 특정 이벤트를 구독하여 생성된 이벤트를 처리하는 모델
- 업스트림, 다운스트림이란 행자와 구독자 간의 데이터 흐름
