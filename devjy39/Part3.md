# PART3

# 8장 컬렉션 API 개선

---

## 컬렉션 팩토리

- 배열 초기화처럼 컬렉션의 초기값 설정

```java
List<Integer> list = new ArrayList<>();
        list.add(1);
        list.add(2);
        list.add(3);

// Arrays에서 배열을 ArrayList 생성자에 넣어서 사이즈가 불변인 리스트를 생성해준다.
List<Integer> list2 = Arrays.asList(1, 2, 3);
```

- 이렇게 생성하게 되면 추가, 삭제 시 UnsupportedOperationExceoption 이 발생한다.
    - 고정된 크기의 배열로 구현되었기 때문

### 리스트 팩토리

- JDK 9 에서 추가된 불변 리스트를 생성하는 리스트 팩토리

```java
List.of(1, 2, 3);

// List.of 메서드의 오버로딩, 1개부터 10개 까지 가변인자를 이용하지 않은 메서드를 만들어놨음
static <E> List<E> of(E e1, E e2, E e3, E e4, E e5, E e6, E e7)
```

- 불변객체를 만들고 싶고 null 방지를 위해선 괜찮은 선택일 수 있다.
- Arrays.asList() 와의 차이점은 10개 까지는 배열 없이 만들 수 있다.
- 가변 인수를 받게되면 추가 배열을 할당 비용이 발생하기 때문에 10개까지 직접 만들어져있다.
- 10개 부터는 가변 인수로 동작된다.
- 같은 방식으로 Set.of를 사용할 수 있다.
    - 집합의 특징 상 중복 값이 있다면 에러를 발생시켜준다.

### 가변 리스트를 간편하게 만들려면?

```java
// stream.of 를 이용해서 만들면 된다.
Stream.of(1, 2, 3).collect(Collectors.toList());
```

### 맵 팩토리

```java
// key 와 value 를 번갈아가며 넣어주면된다.
Map.of("hi", 2, "hello", 5);
 
// Map.entry를 만들어서 넣어준다.       
Map.ofEntries(Map.entry("hi",2), Map.entry("hello",5));
```

- 10개 이하의 요소라면 Map.of를 초과라면 Map.entry를 사용하는게 좋다.

## 리스트와 집합 처리

- jdk8에서 추가된 기능

### removeIf ( List, Set)

- predicate 를 만족하는 요소를 제거한다.

```java
list.removeIf(i -> i%2==0);
```

### replaceAll ( List )

- UnaryOperator 함수를 이용해 요소를 변경한다.

```java
list.replaceAll(i -> i * 2);
```

### sort (List)

- list를 정렬한다.

```java
list.sort((e1, e2) -> e1 - e2);
```

### ConcurrentModificationException

- 위의 기능들을 for-each를 사용해 순회하면서 직접 구현했다면 이 에러를 마주친다.
- 동기화 되지 않는 iterator와 Collection 객체를 동시에 조작하기 때문에 발생하는 에러이다.
- 위의 새로 추가된 메서드를 이용하면 간단하게 처리할 수 있다.

## Map에 추가된 기능

### Map.forEach() ⇒ key와 value 를 인수로 받는 메서드로 손쉽게 반복 가능.

- jdk 8

### comparingBykey, comparingByValue

```java
hashMap.entrySet()
      .stream()
      .sorted(Map.Entry.comparingByValue())
      .forEachOrdered(System.out::println);
```

### getOrDefault

- 기존의 get 에서 키가 없는 경우 null 체크 로직 없이 default 값을 지정해 줄 수 있다.

### compute

- `hashMap.compute("hao", (k, v) -> k.length() + v);`
    - key값을 인수로 받고 해당 value 값을 변경할 수 있다.
        - 하지만 존재하지 않는 key일 경우 nullPointerException이 발생한다.
- computeIfAbsent는 key가 존재하지 않거나 null일 경우 새 값을 추가한다.
    - 캐싱 기능과 유사하게 사용할 수 있다.
- computeIfPresent는 key가 존재하거나 null이면 값을 변경한다.
    - 새로 생성되는 value의 값이 null이면 삭제됨.

### remove

- remove(key, value) : 해당 key와 value에 해당하는 entry가 있다면 삭제한다.

### replace, replaceAll

```java
// hi의 value를 변경
hashMap.replace("hi", 10);

// hi의 value가 2라면 5로 바꾼다.
hashMap.replace("hi", 2, 5);

// 모든 값을 변경
hashMap.replaceAll((k, v) -> k.length() + v);
```

### merge

- 두 개의 맵을 합친다. 중복 키 값에 대한 데이터를 처리하는 함수를 인자로 받는다.

```java
// key가 없다면 value와 함께 추가되고, key가 이미 있다면, 기존의 값을 인자로 새 값으로 변경한다.
hashMap.merge("hi", 10, (k, v) -> Math.max(10, v));
```

## ConcurrentHashMap

- 동시성 처리가 가미된 hashmap이다. 내부 자료구조의 특정 부분만 잠궈 동시 추가, 갱신 작업을 허용한다.
- synchronized로 동기화된 HashTable에 비해 읽기 쓰기 연산 성능이 월등하다.

### 리듀스와 검색

- 새롭게 지원하는 연산
- 키,값으로 연산 - forEach, reduce, search
- 키로 연산 - forEachKey, reduceKeys, searchKeys
- 값으로 연산 - forEachValue, reduceValues, searchValues
- Entry로 연산 - forEachEntry… 등
- 이들의 연산들은 lock을 하지 않고 연산을 수행한다.
    - 인자로 제공한 함수는 진행동안 바뀔 수 있는, 객체, 값, 순서에 의존하지 않아야 한다.
- threshold 병렬 기준값을 제공해야한다.
    - 맵의 크기가 기준값보다 작으면 순차적으로 실행한다.
    - 기준값이 디폴트인 1이면 병렬성을 극대화할 수 있다.

### 계수

- 기존의 size() 는 int 를 반환하기에 Int 범위에 종속적이다.
- mappingCount() 는 long을 반환하므로 안정적으로 사용 가능하다.

### 집합뷰

- ConcurrentHashMap과 동기화되는 KeySet을 반환한다.

---

# 9장 리팩터링, 테스팅, 디버깅

- 람다를 이용해서 기존의 코드에 가독성과 유연성을 높이려면 어떻게 해야할까?
- 람다 표현식은 익명 클래스보다 간결하고, 메서드 참조는 더 간결하고 가독성 있다.

### 코드 가독성

- 가독성이란 다른 사람도 쉽게 이해할 수 있는 코드라는 뜻이다.
- 다른 사람도 쉽게 이해하고 유지보수할 수 있게 프로그램을 만들어야한다.

## 익명 클래스 vs 람다

- 익명 클래스는 this 가 자신을 가르키고, 람다는 현재 속한 class 를 가르킨다.
- 익명 클래스는 변수 선언 시 외부 변수를 무시할 수 있지만, 람다는 변수명 중복 에러가 발생한다.
- 메서드 오버로딩에 람다식을 넣을 경우 인자에 인터페이스가 달라도 표현식이 같으면 어느 것을 호출할지 모호한 문제가 생긴다.
    - ide에서 리팩터링 기능을 이용해 해결 가능

### 람다를 메서드 참조로

- 메서드 참조는 메서드 명으로 코드의 의도를 설명할 수 있어서 더 간결하게 가독성을 높여줄 수 있다.

### 명령형 데이터 처리를 스트림으로

- 반복문을 stream으로 리팩터링하면 가독성과, 지연 연산 효과, 쇼트서킷 등의 이점을 얻을 수 있다.
- 그리고 간단하게 병렬처리할 수 있다.
- 람다를 사용해서 코드 유연성을 확장할 수 있음.

## 디자인 패턴

- 디자인 패턴은 공통적인 소프트웨어 문제를 설계할 때 재사용할 수 있는, 검증된 청사진을 제공한다.
- 람다를 이용해서 디자인 패턴으로 해결하던 문제를 디자인 패턴을 제거하거나 간결하게 재구현할 수 있다.

### 전략 패턴

- 런타임에 적절한 알고리즘을 선택하는 기법
- 전략이 함수형 인터페이스인 경우 구현 클래스를 만들필요 없이 람다로 표현할 수 있다.

### 템플릿 메서드

- 알고리즘의 개요를 제시한 다음 일부를 고칠 수 있는 유연함이 필요할 때 사용되는 기법
- 즉, 제공된 템플릿 로직에서 일부 기능만 확장하고 싶을 때 사용된다.
- 람다를 이용하면 abstract를 구현한 구현체를 일일이 만들필요 없이 인자로 넘겨주면 그만이다.

### 옵저버 패턴

- 어떤 이벤트가 발생했을 때 다른 객체들에 알림을 보내야 하는 경우 사용하는 패턴
- 각각의 옵저버의 동작이 간단할 경우 옵저버 객체를 생성하지 않고 람다로 대체할 수 있다.
- 하지만 옵저버가 상태를 갖고, 여러 메서드가 정의되어 있다면 기존의 클래스 방식을 고수하는게 바람직할 수 있다.

### 의무 체인

- 작업 처리 객체의 체인을 만들 때 사용되는 패턴
- 작업을 처리하고 결과를 다음 작업으로 전달하는 방식
- 체인 패턴은 다음 작업을 체인으로 연결해줘야 하는데, Function은 andThen으로 다음 함수를 연결시켜 줄 수 있었다. 이걸로 작업의 체인을 연결할 수 있다.

### 팩토리

- 인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 사용하는 패턴
- 생성자도 Class:new 메서드 참조가 가능하므로, 해시맵을 이용해 키에 따른 생성자를 반환하게 할 수 있다.
- 하지만 생성자의 인수가 다양할 경우 적용하기 힘들다.

## 람다 테스팅

- 개발자는 작성한 로직이 의도대로 동작하는지 단위 테스팅을 진행해야한다.
- 람다는 익명이므로 테스트코드 에서 이름을 호출할 수 없다. 
따라서 필요하다면 람다를 재사용할 수 있게 저장해서 사용하면 테스트할 수 있다.
- 복잡한 람다식을 테스트하고 싶다면 메서드로 빼서 메서드 참조로 바꾸면 테스트하기 쉽다.

> **람다 표현식을 직접 테스트 하지 말고
사용하는 메서드 자체의 동작을 테스트하는게 바람직하다.**
> 

### 고차원 함수 테스팅

- 람다를 인자로 받거나 다른 함수를 반환하는 (고차원 함수) 메서드는 동작 자체가 추상화되어있기 때문에 테스트하기 어렵다.
- 이런 경우 람다만 따로 빼어 람다식 자체가 원하는 동작을 하는지 테스트할 수 있다.

## 디버깅

- 디버깅 시 개발자는 두 가지를 먼저 확인해야한다.
    - 스택 트레이스
    - 로깅
- 하지만 람다와 스트림은 기존의 디버깅 기법을 무력화한다.

### 스택 트레이스

- 프로그램 실행이 중단되었다면, 중단점과 어떻게 멈췄는지 스택 프레임에서 이 정보를 얻을 수 있다.
- 메서드를 호출할 때마다 호출 위치, 인수값, 지역변수 등을 포함한 호출 정보가 생성되고 스택 프레임에 저장된다.
- 프로그램이 멈췄을 때 이것을 프레임별로 보여주는 게 스택 트레이스다.

### 람다에서 스택 트레이스

- 람다는 이름이 없기 때문에 조금 복잡한 스택 트레이스가 생성된다.

`at Debugging.lambda$main$0(Debugging.java:6)
       at Debugging$$Lambda$5/284720968.apply(Unknown Source)`

- 람다는 이름이 없으므로 컴파일러가 람다를 참조하는 이름을 만들어냈다.
- 메서드 참조를 사용해도 스택 트레이스에 메서드명이 나타나지 않는다.

## 스트림 파이프라인 디버깅

- peek()은 foreach처럼 스트림의 요소를 소비하지 않고, 다음 연산에 넘겨준다.

```java
stream()
	.peek(x -> System::out::println)
	.map(...)
	.peek(x -> System::out::println)
	...
```

이런 느낌으로 각 연산에서 소비한 요소를 출력해볼 수 있다.

---

# 10장 람다를 이용한 도메인 전용 언어

- 저명한 컴퓨터 과학자 하롤드 아벨슨은 “프로그램은 사름들이 이해할 수 있도록 작성하는 것이 중요하며 기기가 실행하는 부분은 부차적일 뿐” 이라고 말했다. 무엇보다 의도가 명확하게 전달되는게 중요하다.
- 개발팀과 도메인 전문가가 공유하는 코드가 읽기 쉽고 이해할 수 있는지는 생산성과 직결되기 때문에 중요하다.
- 도메인 전문가가 개발 프로세스에 참여하면, 비즈니스 관점에서 버그와 오해를 미리 방지할 수 있다.

## 도메인 전용 언어(domain-specific languages, DSL ) 란

- 범용이 아니라 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어다.
- 도메인의 많은 특성 용어를 사용한다.
    - ex) Maven, Ant. ⇒. 빌드 과정을 표현하는 DSL
- 자바에서는 도메인을 표현할 수 있는 클래스와 메서드 집합이 필요하다. 
DSL이란 특정 비즈니스 도메인을 인터페이스로 만든 API라고 생각할 수 있다.
- 범용이 아니므로 오직 해당 도메인에 국한된 문제를 해결할지에 집중할 수 있고 저수준 구현 세부사항을 캡슐화해서 사용자 친화적으로 만들 수 있다.

### 특징

- 코드에 의도가 명확히 드러나야 하고, 비개발자도 이해할 수 있어야한다.
- 쉽게 이해할 수 있는 코드, 가독성이 중요하다.

### 장점

- 간결함 : API는 비즈니스 로직을 캡슐화하므로 반복을 피하고 간결해진다.
- 가독성 : 도메인 영역의 용어를 사용하므로 비 도메인 전문가도 코드를 쉽게 이해할 수 있다.
- 쉬운 유지보수와 확장성
- 높은 수준의 추상화 : 도메인과 같은 추상화 수준에서 동작.
- 관심사분리 : 지정 언어로 로직을 표현해 애플리케이션 인프라구조와 독립적으로 코드에만 집중하기 용이하고  특정 코드에 집중할 수 있어 생산성 증가.

### 단점

- DSL 설계의 어려움
- 비용 : 코드에 DSL을 추가하는 작업은 초기 프로젝트에 많은 비용과 시간이 소모됨.
새로 배워야 하는 비용도 존재
- 추가 우회 계층 : DSL은 추가적인 계층으로 도메인 모델을 감싸며, 이 계층을 최대한 작게 만들어 성능 문제를 피해야한다.
- 호스팅 언어 한계 : DSL을 만드는 언어의 특성에 한계가 있다.

### jvm에서 실행되는 다중 DSL

- 스칼라, 그루비

## 내부 DSL

- 자바(특정 언어)로 구현한 DSL
- 자바로 DSL을 구현하면?
    - 기존 코드와의 호환성, 같이 컴파일 가능, 기존의 IDE 사용
    - 새로 배우지 않아도 됨
- 같은 JVM을 사용하는 언어로 만들어도 이점을 얻을 수 있다.

## 외부 DSL

- 자신만의 문법과 구문으로 새 언어를 설계, 무한한 유연성, 
하지만 호스트 언어와의 계층이 생기고 아주 큰 비용이 든다.

## 효과적인 DSL 패턴

- 효과적으로 DSL을 만들기 위한 여러 패턴이 있고, 다양한 패턴을 조합해서 만들 수 있다.

### 메서드 체이닝

```java
Order order = forCustomer( "BigBank" )
 .buy( 80 )
 .stock( "IBM" )
 .on( "NYSE" )
 .at( 125.00 )
 .sell( 50 )
 .stock( "GOOGLE" )
 .on( "NASDAQ" )
 .at( 375.00 )
 .end();
```

- 메서드가 자신을 반환하게 하여 메서드끼리의 체인을 형성하고 최종 빌더 메서드를 제공해서 객체를 생성한다.
- 가독성이 좋고 간결하다.
- 단점
    - 빌더를 구현해야 한다. 상위 수준의 빌더와 하위 수준의 빌더를 연결할 많은 코드가 필요하다.

### 중첩 함수

```java
Order order = order("BigBank",
 buy(80,
 stock("IBM", on("NYSE")), at(125.00)),
 sell(50,
 stock("GOOGLE", on("NASDAQ")), at(375.00))
 );
```

- 함수안에 함수를 이용해 도메인 모델을 만든다.
- 메서드 체인에 비해 도메인 객체 계층 구조에 그대로 반영된다.
- 단점
    - 메서드로 생성하기 때문에 파라미터에 의존적이다. → 여러 시그니처의 메서드를 구현해야 함.
    - 복잡하고 많은 괄호, 인수 목록을 정석 메서드에 넘겨줘야 함.

### 람다

```java
Order order = order( o -> {
 o.forCustomer( "BigBank" );
 o.buy( t -> {
	 t.quantity( 80 );
	 t.price( 125.00 );
	 t.stock( s -> {
		 s.symbol( "IBM" );
		 s.market( "NYSE" );
 });
 });
 o.sell( t -> {
	 t.quantity( 50 );
	 t.price( 375.00 );
	 t.stock( s -> {
		 s.symbol( "GOOGLE" );
		 s.market( "NASDAQ" );
 });
 });
});
```

- 도메인 객체마다 빌더가 필요하다.
- 반면 메서드 체인 패턴에는 최상위 수준의 빌더를 가졌지만, 
이번에는 Customer 객체를 빌더가 인수로 받아서 DSL 사용자가 람다로 인수를 구현할 수 있게 했다.
- 가독성도 괜찮지만, 많은 설정 코드와 자바8 람다 문법에 의존적임.

### 메서드 참조

```java
double value = new TaxCalculator()
		.with(Tax::regional)
		.with(Tax::surcharge)
		.calculate(order);
```

- 가독성과 유연성, 확장성을 모두 챙길 수 있다.

# DSL 패턴 실사용 사례

## jOOQ

- sql 매핑 도구
- sql을 구현하는 내부적 DSL로 자바에 직접 내장된 형식 안전 언어
- 데이터베이스 스키마를 역공학하는 소스코드 생성기 덕분에 자바 컴파일러가 복잡한 sql구문의 형식을 확인할 수 있다.
- 메서드 체이닝으로 sql 문법을 유연하고 확장성있게 생성할 수 있다.

## 큐컴버

- BDD 개발 프레임워크
- BDD( 행위 주도 개발)는 테스트 주도 개발의 확장으로 다양한 비즈니스 시나리오를 구조적으로 서술하는 도메인 전용 스크립팅 언어를 사용한다.
- Given, When, Then의 세가지 개념으로 테스트 시나리오를 정의한다.

```
Feature: Buy stock
 Scenario: Buy 10 IBM stocks
 Given the price of a "IBM" stock is 125$
 When I buy 10 "IBM"
 Then the order value should be 1250$
```

- 요즘 애플리케이션 개발에서도 테스트 코드를 작성할 때 이 정의를 많이 따르면서 작성하는걸로 알고 있다.

## 스프링 통합

- 엔터프라이즈 통합 패턴을 지원할 수 있도록 의존성 주입에 기반해 모델을 확장한다.
- 스프링 기반 애플리케이션 내의 경량의 원격, 메시징, 스케쥴링을 지원한다.
- 엔드포인트, 폴러, 채널 인터셉터 등 메시지 기반의 애플리케이션에 필요한 공통 패턴을 모두 구현한다.
- 스프링 통합의 핵심 목표는 복잡한 엔터프라이즈
통합 솔루션을 구현하는 단순한 모델을 제공하고 비동기, 메시지 주도 아키텍처를 쉽게 적용할
수 있게 돕는 것이다



<aside>
💡 웹 애플리케이션 개발을 하면서 접했던 것들이 전부 특정 도메인을 위한 DSL이었다는 것을 알게 되었고 왜 만들어졌는지 생각할 수 있게 되었다.

</aside>
