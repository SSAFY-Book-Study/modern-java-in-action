# Part3

# Part2 스트림과 람다를 이용한 효과적 프로그래밍

## Ch.8 컬렉션 API 개선

- 컬렉션 팩토리
    - 고정 크기의 리스트에 요소를 추가하려 하면 UnsupportedOperationException 발생
    - 리스트 팩토리
        - List.of 팩토리 메소드로 간단하게 리스트 만들기 가능 (바꿀 수 없는 리스트)
            - 팩토리 메소드 : 객체를 생성 반환하는 메소드
        - 데이터 처리 형식을 설정하거나 데이터를 변환할 필요가 없다면 팩토리 메서드 이용 권장
    - 집합 팩토리
        - Set.of로 바꿀 수 없는 집합 만들기 가능
        - 중복된 요소를 포함하여 만들려 하면 IllegealArugumentException 발생
    - 맵 팩토리
        - 리스트나 집합에 비해 복잡
        - 10개 이하 키와 값 쌍 → Map.of, 그 이상 → Map.Entry<K, V>을 이용한 Map.ofEntries
- 리스트와 집합 처리
    - remove If
        - 프레디케이트 만족하는 요소 제거
        - List
    - replaceAll
        - UnaryOpreator 함수를 이용해 요소 변경
        - List, Set
    - sort
        - 리스트 정렬
        - List
- 맵 처리
    - forEach 메서드
        - 맵에서 키와 값을 반복하면서 확인
    - 정렬 메서드
        - 맵의 항목을 값 또는 키를 기준으로 정렬
        - Entry.comparingByValue, Entry.comparingByKey
    - getOrDefault 메서드
        - null 방지, 키가 없으면 두번째 인수를 기본값으로 반환
    - 계산 패턴
        - computeIfAbsent
            - 제공된 키에 해당 값이 없으면, 키를 이용해 새 값을 계산하고 맵에 추가
        - computeIfPresent
            - 제공된 키가 존재하면 새 값을 계산하고 맵에 추가
        - compute
            - 제공된 키로 새 값을 계산하고 맵에 저장
    - 삭제 패턴
        - remove
    - 교체 패턴
        - repleaceAll
            - BiFunction을 적용한 결과로 각 항목의 값을 교체
        - replace
            - 키가 존재하면 맵의 값을 교체
- 개선된 ConcurrentHashMap
    - 동시성 친화적이며 최신 기술을 반영한 HashMap
    - Map에서 상속받은 새 디폴트 메서드를 지원함과 동시에 스레드 안전성 제공

## Ch.9 리팩터링, 테스팅, 디버깅

- 가독성과 유연성을 개선하는 리팩터링
    - 코드 가독성 개선
    - 익명 클래스를 람다 표현식으로 리팩터링하기
        - 모든 익명 클래스를 람다 표현식 변환 x
            - this, 변수 섀도 등 주의
        - 콘텍스트 오버로딩에 따른 모호함 초래 주의
    - 람다 표현식을 메서드 참조로 리팩터링하기
        - 메서드 참조는 자신의 동작을 메서드 이름으로 설명하여 더욱 가독성이 좋음
    - 명령형 데이터 처리를 스트림으로 리팩터링하기
        - 반복적인 컬렉션 처리 코드는 스트림 API로 교체
    - 코드 유연성 개선
        - 함수형 인터페이스 적용
        - 조건부 연기 실행
        - 실행 어라운드
- 람다로 객체지향 디자인 패턴 리팩터링하기
    - 디자인 패턴 : 다양한 패턴을 유형별로 정리
    - 전략
        - 전략 패턴 : 한 유형의 알고리즘을 보유한 상태에서 런타임에 적절한 알고리즘을 선택하는 기법
    - 템플릿 메서드
        - 알고리즘의 개요를 제시한 다음에 알고리즘의 일부를 고칠 수 있는 유연함을 제공해야 할 때 사용
    - 옵저버
        - 어떤 이벤트가 발생했을 때 한 객체가 다른 객체 리스트에 자동으로 알림을 보내야 하는 상황
    - 의무 체인
        - 작업 처리 객체의 체인을 만들 때 사용
    - 팩토리
        - 인스턴스화 로직을 클라이언트에 노출하지 않고 객체를 만들 때 팩토리 디자인 패턴을 사용
- 람다 테스팅
    - 단위 테스트 수행
    - 메서드의 동작에 집중
    - 복잡한 람다 개별 메서드로 분할
    - 고차원 함수 테스팅
- 디버깅
    - 스택 트레이스
    - 로깅
        - peek 메서드로 중간값 확인 가능

## Ch.10 람다를 이용한 도메인 전용 언어

- 도메인 전용 언어 (DSL) : 작은, 범용이 아니라 특정 도메인을 대상으로 만들어진 특수 프로그래밍 언어
    - 주요 기능 : 개발자와 도메인 전문가 사이의 간격을 좁히는 것
- DSL은 내부적 DSL과 외부적 DSL로 분류할 수 있다.
    - 내부적 DSL
        - DSL이 사용될 애플리케이션을 개발한 언어를 그대로 활용
        - 개발 노력이 적게 듦, 호스팅 언어의 문법 제약
    - 외부적 DSL
        - 직접 언어를 설계하여 사용
        - 높은 유연성을 제공하지만, 구현 어려움
- JVM에서 이용할 수 있는 스칼라, 그루비 등의 다른 언어로 다중 DSL을 개발
    - 자바보다 유연하며 간결한 편
    - 자바와 통합하려면 빌드 과정의 복잡, 자바와의 상호 호환성 문제 존재
- 자바는 장황함과 문법적 엄격함으로 내부적 DSL 언어로 부적합하였으나, 람다와 메서드 참조의 등장으로 많이 개선