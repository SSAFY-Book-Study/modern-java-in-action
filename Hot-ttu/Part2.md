# Part2 함수형 데이터 처리

## Ch4. 스트림 소개

- 스트림 : 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소
- 스트림은 filter, map, sorted 등의 연산으로 반복을 추상화
  - 외부 반복 : 사용자가 직접 요소를 반복
    - 컬렉션 사용
  - 내부 반복 : 반복을 알아서 처리하고 결과 스트림값을 어딘가 저장
    - 스트림 사용
- 스트림에는 중간 연산과 최종 연산이 존재
  - 중간 연산 : 스트림을 연결할 수 있는 연산, 중간 연산으로는 결과 생성 x
    - filter, map, limit 등
  - 최종 연산 : 스트림을 닫는 연산, 스트림이 아닌 결과를 반환
    - forEachm, count
- 스트림 요소는 요청할 때 게으르게 계산
  - 중간 연산을 합친 다음에 중간 연산을 최종 연산으로 한 번에 처리

## Ch5. 스트림 활용

- 스트림 API를 이용하면 복잡한 데이터 처리 질의를 표현 가능
- 필터링
  - 프레디케이트 필터링
    - 프레디케이트(불리언을 반환하는 함수)를 인수로 받아서 일치하는 모든 요소를 포함하는 스트림을 반환
  - 고유 요소 필터링
    - distinct()메서드 활용
- 슬라이싱
  - 프레디케이트 이용
    - takeWhile(), dropWhile() 활용
    - dropWhile()은 프레디케이트가 처음으로 거짓이 되는 지점까지 발견된 요소를 버림
  - 스트림 축소
    - limit() 메서드 활용
  - 요소 건너뛰기
    - skip() 메서드 활용
- 매핑
  - 각 요소에 함수 적용
    - map() 메서드 활용
  - 스트림 평면화
    - map + Arrays.stream 활용
    - flatMap() 메서드 활용
- 검색과 매칭
  - anyMatch()
    - 스트림에서 적어도 한 요소와 일치하는지 확인, 불리언 반환 -> 최종 연산
  - allMatch()
    - 스트림의 모든 요소가 일치하는지 확인
  - NoneMatch()
    - 주어진 프레디케이트와 일치하는 요소가 없는지 확인
  - 위 메서드들은 쇼트서킷으로 결과를 찾는 즉시 반환
  - 요소 검색
    - filter, findAny() 활용
  - 첫번째 요소 찾기
    - 논리적인 아이템 순서가 있을 때, findFirst() 메서드 활용
- 리듀싱
  - 모든 스트림 요소를 처리해서 값으로 도출
  - reduce()메서드 활용
  - 최댓값, 최솟값, 모든 요소의 합계 계산
- 숫자형 스트림
  - 숫자스트림으로 매핑
    - mapToInt, mapToDouble, mapToLong
    - boxed 활용하여 일반 스트림으로 변환
  - 숫자 범위
    - range(), rangeClosed() 활용
    - rangeClosed는 시작값, 종료값 포함
- 스트림 만들기
  - 값으로 스트림 만들기
    - Stream.of 활용
    - Stream.empty로 비우기 가능
  - null이 될 수 있는 객체로 스트림 만들기
    - Stream.ofNullable 활용
  - 배열로 스트림 만들기
    - Arrays.stream 활용
  - 파일로 스트림 만들기
    - java.nio.file.Files의 많은 정적 메서드가 스트림 반환
  - 함수로 무한 스트림 만들기
    - 무한 스트림 : 크기가 고정되지 않은 스트림
    - itreate 메서드
    - generate 메서드

## Ch.6 스트림으로 데이터 수집

- collect는 스트림의 요소를 요약 결과로 누적하는 다양한 방법(Collector 인터페이스에 정의)을 인수로 갖는 최종 연산
- 컬렉터
  - 고급 리듀싱 기능을 수행하는 컬렉터
    - toList() 등
  - 미리 정의된 컬렉터
    - 스트림 요소를 하나의 값으로 리듀스하고 요약
    - 요소 그룹화
    - 요소 분할
- 리듀싱과 요약
  - 스트림값에서 최댓값과 최솟값 검색
    - Collectors.maxBy(), Collectors.minBy() 메서드 활용
  - 요약 연산
    - 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산
    - Collectors.summingInt(), summingLong(), summingDouble()
  - 문자열 연결
    - joining() 활용
      - 내부적으로 StringBuilder 사용
  - 범용 리듀싱 요약 연산
    - reducing() 메서드로 위 모든 컬렉터 정의 가능
- 그룹화
  - Collectors.groupingBy로 그룹화 (분류 함수)
- 분할
  - Collectors.partitioningBy로 분할 (분할 함수)
- Collector 인터페이스
  - supplier : 새로운 결과 컨테이너 만들기
  - accumulator : 결과 컨테이너에 요소 추가
  - finisher : 최종 반환값을 결과 컨테이너로 적용
  - combiner : 두 결과 컨테이너 병합
  - Characteristics : 컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환
- Collector 인터페이스에 정의된 메서드를 구현하여 커스텀 컬렉터 개발 가능

## Ch.7 병렬 데이터 처리와 성능

- 병렬 스트림
  - 컬렉션에 parallelStram을 호출하면 병렬 스트림 생성
    - 병렬 스트림 : 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림
  - parallel()로 순차 스트림 -> 병렬 스트림, sequential()로 병렬 스트림 -> 순차 스트림
  - 병렬 스트림이라고 항상 성능이 좋은 것은 x (반복 작업은 수행할 수 있는 독립 단위로 나누기 어려움)
  - 효과적으로 사용하기
    - 확신이 서지 않으면 직접 측정
    - 박싱을 주의
    - 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산 존재
    - 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려
    - 소량의 데이터에서는 병렬 스트림이 도움되지 않음
    - 스트림을 구성하는 자료구조 확인
    - 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는 지 확인
    - 최종 연산의 병합 과정 비용 확인
- 포크/조인 프레임워크
  - 병렬화할 수 있는 작업은 재귀적으로 작은 작업으로 분할한 다음에 서브태스크 각각의 결과를 합쳐서 전체 결과를 만들도록 설계
- Spliterator 인터페이스
  - Spliterator : 분할할 수 있는 반복자
  - 탐색하려는 데이터를 포함하는 스트림을 어떻게 병렬화할 것인지 정의