## Chapter4 스트림 소개

### 스트림이란?

스트림이 없던 자바에서는 컬렉션에 대한 단순 반복 처리 코드가 복잡하며 성능을 올리기 위한 병렬 처리 코드는 더 복잡하다

스트림은 컬렉션 반복을 멋지게 처리하는 기능이라고 생각
**스트림을 이용하면 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다**

자바7에서의 컬렉션 처리
```java
List<Dish> lowCaloricDishes = new ArrayList<>();
for(Dish dish : menu) {    // <- 누적자로 요소 필터링
  if(dish.getCalories() < 400) {
    lowCaloricDishes.add(dish);
  }
}
Collections.sort(lowCaloricDishes, new Comparator<Dish>() {  // <- 익명 클래스로 요리 정렬
  public int compare(Dish dish1, Dish dish2) {
    return Integer.compare(dish1.getCalories(), dish2.getCalories());
  });
List<String> lowCaloricDishesName = new ArrayList<>();
for(Dish dish : lowCaloricDishes) {
  lowCaloricDishesName.add(dish.getName());  // <- 정렬된 리스트를 처리하면서 요리 이름 선택
}
```
lowCaloricDishes라는 `가비지 변수`를 사용했으며 요구사항에 따라 반복자를 통해 처리를 하는 복잡하고 긴 코드이며 유지보수 비용이 크다

자바8에서의 컬렉션 처리
```java
List<String> lowCaloricDishesName =
            menu.stream()
            .filter(d -> d.getCalories() < 400)    // <- 400칼로리 이하 요리 선택
            .sorted(comparing(Dish::getCalories))  // <- 칼로리로 요리 정렬
            .map(Dish::getName)    // <- 요리명 추출
            .collect(toList());    // <- 모든 요리명을 리스트에 저장
```
stream을 사용하면 변화하는 요구사항에도 쉽게 대응할 수 있으며 Stream을 parallelStream으로 변경하면 병렬로 처리하는 성능을 올릴 수 있다

자바8 스트림 API의 특징
- 선언형: 더 간결하고 가독성이 좋아짐
- 조립할 수 있음: 유연성이 좋아진다
- 병렬화: 성능이 좋아진다

### 스트림 시작하기

스트림이란 `데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소`로 정의할 수 있음

- 연속된 요소
  - 컬렉션과 마찬가지로 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공
  - 컬렉션은 시간과 공간 복잡성과 관련된 요소 저장 및 접근 연산이 주를 이룸 (데이터)
  - 스트림은 filter, sorted, map처럼 표현 계산식이 주를 이룸  (계산)
- 소스
  - 데이터 제공 소스로부터 데이터를 소비
  - 전달받은 데이터 순서 유지
- 데이터 처리 연산
  - 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원
 
스트림의 중요 특징   
- 파이프라이닝
  - 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 **스트림 자신을 반환**
  - `게으름`, `쇼트서킷`같은 최적화
- 내부 반복
  - 반복자를 통한 명시적 반복인 외부 반복과 달리 내부 반복을 지원
  - 반복을 처리하고 결과 스트림 값을 어딘가에 저장해줌

### 스트림과 컬렉션

스트림과 컬렉션의 차이를 설명하고 있다
비유를 들어 설명하고 있는데
컬렉션은 **DVD에 저장된 영화로 모든 데이터를 내려받고 가지고 있다**고 표현
스트림은 **인터넷으로 스트리밍하는 영화로 모든 데이터를 내려받지 않고 필요할 때 값을 받아 처리**한다고 표현하고 있다
- 데이터를 언제 계산하느냐?
- 모든 값을 저장, 처리해야 하는가?
- 반복 처리 방식 (외부 반복과 내부 반복)

### 스트림 연산

앞서 살펴보았을 때 스트림은 **파이프라이닝을 통해 스트림 연산끼리 연결하여 결과로 스트림을 반환**한다고 하였다
이에 따라 **연결할 수 있는 스트림 연산을** `중간 연산`이라고 하며 **스트림을 닫는 연산을** `최종 연산`이라고 한다

중간 연산
- filter나 sorted 같은 중간 연산은 다른 스트림을 반환
- **단말 연산을 스트림 파이프라인에 실행하기 전**까지는 아무 연산도 수행하지 않는다는 것 -> **게으르다**
  - 중간 연산을 합친 다음에 합쳐진 중간 연산을 최종 연산으로 한 번에 처리
 
최종 연산
- 최종 연산에 의해 스트림 파이프라인에서 결과를 도출
  - 도출한 결과는 List, Integer, void 등 스트림 이외의 결과가 반환
 
스트림 이용 과정은 세 가지로 요약할 수 있음
1. 질의를 수행할 (컬렉션 같은) 데이터 소스
2. 스트림 파이프라인을 구성할 중간 연산 연결
3. 스트림 파이프라인을 실행하고 결과를 만들 최종 연산

### 정리

- 스트림은 소스에서 추출된 연속 요소로 데이터 처리 연산을 지원
- 스트림은 내부 반복을 지원하며 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화
- 스트림에는 중간 연산과 최종 연산이 있음
- 중간 연산은 filter, map 처럼 스트림을 반환하면서 다른 연산과 연결되는 연산
- forEach나 count 처럼 스트림 파이프라인을 처리해서 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고 한다
- 스트림의 요소는 요청할 때 게으르게 계산된다

