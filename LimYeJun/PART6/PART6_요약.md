## Chapter18 함수형 관점으로 생각하기

함수형이란 무엇인지 앞에서 설명한 적이 있었다
- 전역 변수를 사용하거나 변경하지 않아 side effect를 없애는 방식의 pure function
- 함수를 인자로 받거나 함수를 반환값으로 이용 할 수 있음
- 불변성
  - 불변성을 통해 Thread safe, 병렬처리, 함수 조합을 안전하게 제공
이번 챕터에서는 함수형 프로그래밍의 개념, 기법을 좀 더 자세히 살펴본다

### 시스템 구현과 유지보수

실제 경험해본 적은 없는 대규모 소프트웨어 시스템 업그레이드 관리를 누군가가 요청했을 때 
노련한 개발자라면 `synchronized`라는 키워드가 발견된다면 제안을 거절하라, `synchronized`가 없다면 시스템의 구조를 자세히 검토해보라는 풍문이 떠돌 정도라고 한다

그 만큼 **변수의 값을 바꿀 수 있는 상태에 있는 변수를 사용하는** 부분은 유지보수하기 쉽지 않다는 것을 의미한다

실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 되며 코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다

왜 그리고 어떻게 변숫값이 바뀐 걸까? (전역 변수의 사용?)
함수형 프로그래밍이 제공하는 **부작용 없음 (no side effect), 불변성(immutablility)**이라는 개념이 이 문제를 해결하는 데 도움을 준다

#### 공유된 가변 데이터
- 변수가 예상하지 못한 값을 갖는 이유는 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다

리스트를 참조하는 여러 클래스가 있다고 가정
- 리스트의 소유자는 어느 클래스가 되는가?
- 이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 되는가?
  - 다른 클래스는 리스트가 갱신되었다는 사실을 알고 있을까?
  - 다른 클래스에 리스트가 갱신되었음을 어떻게 알려줄 수 있는가?
  - 리스트의 갱신을 알리는 것과 사본을 만드는 것?
이처럼 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기 어려워짐

-> 예상하지 못하게 자료구조의 값이 바뀔 일이 없도록한다면 유지보수가 쉬움
자신을 포함하는 클래스의 상태, 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 **순수 메서드, 부작용 없는 메서드**라고 부른다

구체적인 부작용의 예
- 자료구조를 고치거나 필드에 값을 할당(Setter 메서드 같은 생성자 외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

불변 객체를 이용해서 부작용을 없애는 방법도 존재
- 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않음

#### 선언형 프로그래밍
함수형 프로그래밍의 기반을 이루는 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있음
- `이 일을 먼저하고, 그 다음에 값을 갱신하고, ..`처럼 `어떻게` 수행할 것인지에 집중하는 방법 -> 고전의 객체지향 프로그래밍에서 이용하는 방식, 명령형 프로그래밍
- `어떻게`가 아닌 `무엇을`에 집중하는 방식 -> 스트림 API로 **내부 반복**을 통해 문제를 어떻게 푸는지 명확하게 보여주는 **선언형 프로그래밍**

선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고, 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다
-> 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점

#### 왜 함수형 프로그래밍인가?
- 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, **부작용이 없는 계산을 지향**
- 람다 표현식을 이용해서 보여준 것 처럼 **작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는 데 도움을 줌**

### 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍에서 **함수**란 수학적인 함수와 같다
- 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다**
- 다른 객체의 필드를 고치거나 상태 변화가 없어야한다

- `함수, if-then-else 등의 수학적 표현만 사용`하는 방식을 순수 함수형 프로그래밍이라고 함
- `시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용`하는 방식을 함수형 프로그래밍이라 한다

#### 함수형 자바
실질적으로 자바는 **완벽한 순수 함수형 프로그래밍을 구현하기 어렵다**
- 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것
- 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 **함수형**을 달성할 수 있음

만약 메서드의 작업이 어떤 필드의 값을 증가시켰다가 빠져 나올 때 필드의 값을 돌려놓는다고 가정하면 
**단일 스레드에서는 부작용이 없기 때문에 함수형이라고 간주**
하지만 다른 스레드가 필드의 값을 중간에 확인한다든가 동시에 메서드를 호출한다면 **이 메서드는 함수형이 아니게 됨**
메서드의 바디를 잠금으로써 문제를 해결할 수 있으며 이 때 함수형이라고 할 수 있음
하지만 병렬로 호출할 수 없음
-> 함수형으로 구현했지만, 프로그램의 실행속도가 느려지게 된 것

따라서 함수형은
- 지역 변수만을 변경해야 함
- 참조하는 객체가 있다면 불변 객체여야 함
- 예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있지만, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하며 다음에 메서드를 호출한 결과에 영향을 미치지 않아야 함

함수형은 예외가 발생할 수 있을 경우 함수형에 위배되는 제어 흐름이 발생하여 함수형을 위배할 수 있다
-> 함수형은 어떠한 예외도 일으키지 않아야 한다
- 값을 나누는 메서드에서 0으로 나누는 경우 예외 처리가 필요함
  - Optional을 사용하여 예외 없이도 결과 값으로 연산을 성공적으로 수행했는지, 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있음
 
함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다
- insertAll이라는 메서드 내에서 List.add를 호출하기 전에 미리 리스트를 복사함으로써 라이브러리 함수에서 일으키는 부작용을 감춘다
  - List.add는 요소를 추가하는 비함수형 메서드인데, 함수형 내부에서 비함수형을 호출하여 어떤 필드를 수정하게 되면 부작용이 발생
  - 미리 리스트를 복사하고 add한다는 것은 새로 생성한 객체의 필드를 갱신하는 함수형 특징을 활용하는 것으로 볼 수 있다


