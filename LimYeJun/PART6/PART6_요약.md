## Chapter18 함수형 관점으로 생각하기

함수형이란 무엇인지 앞에서 설명한 적이 있었다
- 전역 변수를 사용하거나 변경하지 않아 side effect를 없애는 방식의 pure function
- 함수를 인자로 받거나 함수를 반환값으로 이용 할 수 있음
- 불변성
  - 불변성을 통해 Thread safe, 병렬처리, 함수 조합을 안전하게 제공
이번 챕터에서는 함수형 프로그래밍의 개념, 기법을 좀 더 자세히 살펴본다

### 시스템 구현과 유지보수

실제 경험해본 적은 없는 대규모 소프트웨어 시스템 업그레이드 관리를 누군가가 요청했을 때 
노련한 개발자라면 `synchronized`라는 키워드가 발견된다면 제안을 거절하라, `synchronized`가 없다면 시스템의 구조를 자세히 검토해보라는 풍문이 떠돌 정도라고 한다

그 만큼 **변수의 값을 바꿀 수 있는 상태에 있는 변수를 사용하는** 부분은 유지보수하기 쉽지 않다는 것을 의미한다

실질적으로 많은 프로그래머가 유지보수 중 코드 크래시 디버깅 문제를 가장 많이 겪게 되며 코드 크래시는 예상하지 못한 변숫값 때문에 발생할 수 있다

왜 그리고 어떻게 변숫값이 바뀐 걸까? (전역 변수의 사용?)
함수형 프로그래밍이 제공하는 **부작용 없음 (no side effect), 불변성(immutablility)**이라는 개념이 이 문제를 해결하는 데 도움을 준다

#### 공유된 가변 데이터
- 변수가 예상하지 못한 값을 갖는 이유는 우리가 유지보수하는 시스템의 여러 메서드에서 공유된 가변 데이터 구조를 읽고 갱신하기 때문이다

리스트를 참조하는 여러 클래스가 있다고 가정
- 리스트의 소유자는 어느 클래스가 되는가?
- 이들 중 하나의 클래스가 리스트를 갱신하면 어떻게 되는가?
  - 다른 클래스는 리스트가 갱신되었다는 사실을 알고 있을까?
  - 다른 클래스에 리스트가 갱신되었음을 어떻게 알려줄 수 있는가?
  - 리스트의 갱신을 알리는 것과 사본을 만드는 것?
이처럼 공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기 어려워짐

-> 예상하지 못하게 자료구조의 값이 바뀔 일이 없도록한다면 유지보수가 쉬움
자신을 포함하는 클래스의 상태, 다른 객체의 상태를 바꾸지 않으며 return 문을 통해서만 자신의 결과를 반환하는 메서드를 **순수 메서드, 부작용 없는 메서드**라고 부른다

구체적인 부작용의 예
- 자료구조를 고치거나 필드에 값을 할당(Setter 메서드 같은 생성자 외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

불변 객체를 이용해서 부작용을 없애는 방법도 존재
- 불변 객체는 인스턴스화한 다음에는 객체의 상태를 바꿀 수 없는 객체이므로 함수 동작에 영향을 받지 않음

#### 선언형 프로그래밍
함수형 프로그래밍의 기반을 이루는 선언형 프로그래밍

프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있음
- `이 일을 먼저하고, 그 다음에 값을 갱신하고, ..`처럼 `어떻게` 수행할 것인지에 집중하는 방법 -> 고전의 객체지향 프로그래밍에서 이용하는 방식, 명령형 프로그래밍
- `어떻게`가 아닌 `무엇을`에 집중하는 방식 -> 스트림 API로 **내부 반복**을 통해 문제를 어떻게 푸는지 명확하게 보여주는 **선언형 프로그래밍**

선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고, 시스템이 어떻게 그 목표를 달성할 것인지 등의 규칙을 정한다
-> 문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점

#### 왜 함수형 프로그래밍인가?
- 함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며, **부작용이 없는 계산을 지향**
- 람다 표현식을 이용해서 보여준 것 처럼 **작업을 조합하거나 동작을 전달하는 등의 언어 기능은 선언형을 활용해서 자연스럽게 읽고 쓸 수 있는 코드를 구현하는 데 도움을 줌**

### 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍에서 **함수**란 수학적인 함수와 같다
- 함수는 0개 이상의 인수를 가지며, 한 개 이상의 결과를 반환하지만 **부작용이 없어야 한다**
- 다른 객체의 필드를 고치거나 상태 변화가 없어야한다

- `함수, if-then-else 등의 수학적 표현만 사용`하는 방식을 순수 함수형 프로그래밍이라고 함
- `시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 기능도 사용`하는 방식을 함수형 프로그래밍이라 한다

#### 함수형 자바
실질적으로 자바는 **완벽한 순수 함수형 프로그래밍을 구현하기 어렵다**
- 순수 함수형이 아니라 **함수형 프로그램**을 구현할 것
- 실제 부작용이 있지만 아무도 이를 보지 못하게 함으로써 **함수형**을 달성할 수 있음

만약 메서드의 작업이 어떤 필드의 값을 증가시켰다가 빠져 나올 때 필드의 값을 돌려놓는다고 가정하면 
**단일 스레드에서는 부작용이 없기 때문에 함수형이라고 간주**
하지만 다른 스레드가 필드의 값을 중간에 확인한다든가 동시에 메서드를 호출한다면 **이 메서드는 함수형이 아니게 됨**
메서드의 바디를 잠금으로써 문제를 해결할 수 있으며 이 때 함수형이라고 할 수 있음
하지만 병렬로 호출할 수 없음
-> 함수형으로 구현했지만, 프로그램의 실행속도가 느려지게 된 것

따라서 함수형은
- 지역 변수만을 변경해야 함
- 참조하는 객체가 있다면 불변 객체여야 함
- 예외적으로 메서드 내에서 생성한 객체의 필드는 갱신할 수 있지만, 새로 생성한 객체의 필드 갱신이 외부에 노출되지 않아야 하며 다음에 메서드를 호출한 결과에 영향을 미치지 않아야 함

함수형은 예외가 발생할 수 있을 경우 함수형에 위배되는 제어 흐름이 발생하여 함수형을 위배할 수 있다
-> 함수형은 어떠한 예외도 일으키지 않아야 한다
- 값을 나누는 메서드에서 0으로 나누는 경우 예외 처리가 필요함
  - Optional을 사용하여 예외 없이도 결과 값으로 연산을 성공적으로 수행했는지, 요청된 연산을 성공적으로 수행하지 못했는지 확인할 수 있음
 
함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다
- insertAll이라는 메서드 내에서 List.add를 호출하기 전에 미리 리스트를 복사함으로써 라이브러리 함수에서 일으키는 부작용을 감춘다
  - List.add는 요소를 추가하는 비함수형 메서드인데, 함수형 내부에서 비함수형을 호출하여 어떤 필드를 수정하게 되면 부작용이 발생
  - 미리 리스트를 복사하고 add한다는 것은 새로 생성한 객체의 필드를 갱신하는 함수형 특징을 활용하는 것으로 볼 수 있다

#### 참조 투명성
`부작용을 감춰야 한다`라는 제약은 **참조 투명성**개념으로 귀결된다
- 같은 인수로 함수를 호출했을 때 항상 같은 결과를 반환한다면 참조적으로 투명한 함수
- 함수는 어떤 입력이 주어져을 때 언제, 어디서 호출하든 같은 결과를 생성해야 한다

Scanner가 키보드 입력을 받는다면 참조 투명성을 위배
final int 변수를 더하는 연산에서는 두 변수를 바꿀 수 없으므로 항상 같은 결과를 생성

자바에서는 참조 투명성과 관련한 작은 문제가 있다
- List를 반환하는 메서드를 두 번 호출한다고 가정
  - 두 번의 호출 결과로 같은 요소를 포함하지만 서로 다른 메모리 공간에 생성된 리스트를 참조
  - 결과 리스트가 가변 객체라면 리스트를 반환하는 메서드는 참조적으로 투명한 메서드가 아니라는 결론이 나옴
  - 결과 리스트를 불변의 순수값으로 사용할 것이라면 두 리스트가 같은 객체라고 볼 수 있으므로 리스트 생성 함수는 참조적으로 투명한 것으로 간주
-> 일반적으로 **함수형 코드에서는 이런 함수를 참조적으로 투명한 것으로 간주한다**

#### 객체지향 프로그래밍과 함수형 프로그래밍
프로그래밍 형식을 스펙트럼으로 표현하면
한 쪽 끝에는 **모든 것을 객체로 간주하고, 프로그램이 객체의 필드를 갱신, 메서드를 호출하여 관련 객체를 갱신하는 방식**의 익스트림 객체지향 방식이 위치
반대쪽 끝에는 참조적 투명성을 중시하는, 즉 변화를 허용하지 않는 함수형 프로그래밍 형식이 위치
-> 객체지향과 함수형은 정반대의 프로그래밍 방식

실제로 자바 프로그래머는 이 두 가지 프로그래밍 형식을 혼합하여 사용한다

### 재귀와 반복
순수 함수형 프로그래밍 언어에선 while, for 같은 반복문을 포함하지 않는다
반복문 때문에 변화가 자연스럽게 코드에 스며들 수 있기 때문

다른 누군가가 변화를 알아차리지만 못한다면 아무 상관이 없다 -> 지역 변수는 자유롭게 갱신이 가능
하지만 루프 내부에서 프로그램의 다른 부분과 공유되는 객체의 상태를 변화시키면 안됨
```java
public void searchForGold(List<String> l, Stats stats) {
  for(String s : l) {
    if("gold".equals(s)) {
        stats.incrementFor("gold");  // 공유된 객체의 상태를 변화!
    }
  }
}
```
순수 함수형 프로그래밍 언어에서는 부작용 연산을 원칙적으로 제거했다
-> 재귀를 이용하면 변화가 일어나지 않으며, 루프 단계마다 갱신되는 반복 변수를 제거할 수 있다

```java
// 반복 방식의 팩토리얼
static int factorialIterative(int n) {
	int r = 1;
    for (int i = 1; i <= n; i++) {
    	r *= i;
    }
    return r;
}
```

```java
// 재귀 방식의 팩토리얼
static long factorialRecursive(long n) {
	return n == 1 ? 1 : n * factorialRecursive(n-1);
}
```

- 첫번째 예제에서는 일반적인 루프를 사용하여 변수 r과 i가 갱신
- 두번째 예제에서는 재귀 방식의 코드로 좀 더 수학적인 형식으로 문제를 해결

효율성 측면으로 두 방식을 비교해본다면 무조건 반복보다는 재귀가 좋다고 주장하는 함수형 프로그래밍 광신도의 주장에 주의해야 한다고 한다
일반적으로 반복 코드보다 재귀 코드가 더 비싸다 -> 호출 스택에 각 호출 시 생성되는 정보를 저장할 새로운 스택 프레임이 만들어지기 때문

그렇지만 **함수형 언어에서는 꼬리 호출 최적화**라는 해결책을 제공한다
- 중간 결과를 각각의 스택 프레임으로 저장해야 하는 일반 재귀와 달리 꼬리 재귀에서는 컴파일러가 하나의 스택 프레임을 재활용할 가능성이 생김
![스크린샷 2023-10-01 오후 8 30 43](https://github.com/dpwns523/modern-java-in-action/assets/84260096/d92ad256-f5bf-4dab-b29d-2fd25feceadc)

```java
// 꼬리 재귀 팩토리얼
static long factorialTailRecursive(long n) {
  return factorialHelper(1, n);
}
static long factorialHelper(long acc, long n) {
  return n == 1 ? acc : factorialHelper(acc*n, n-1);
}
```
factorialHelper의 정의에서는 중간 결과(팩토리얼의 부분결과)를 함수의 인수로 직접 전달

![스크린샷 2023-10-01 오후 8 32 48](https://github.com/dpwns523/modern-java-in-action/assets/84260096/4cce76e1-d8ed-456e-9763-a64dc5cae5c0)

**안타깝게도 자바는 이와 같은 최적화를 제공하지 않지만 고전적인 재귀보다는 여러 컴파일러 최적화 여지를 남겨둘 수 있는 꼬리 재귀를 사용하는 것이 좋다**
스칼라, 그루비 같은 최신 JVM 언어는 이와 같은 재귀를 반복으로 변환하는 최적화를 제공한다

**자바8에서는 반복을 스트림으로 대체해서 변화를 피할 수 있다** 또한 반복을 재귀로 바꾸면 간결하고, 부작용이 없는 알고리즘을 만들 수 있다

### 정리
- 공유된 가변 자료구조를 줄이는 것은 장기적으로 프로그램을 유지보수하고 디버깅하는데 도움이 된다
  - 작은 메모리를 최적화하겠다고, 가변 자료구조를 공유하는것은 유지보수에 큰 비용을 지불하게 한다
- 함수형 프로그래밍은 부작용이 없는 메서드와 선언형 프로그래밍 방식을 지향한다
- 함수형 메서드는 입력 인수와 출력 결과만을 갖는다
- 같은 인수값으로 함수를 호출했을 때 항상 같은 값을 반환하면 참조 투명성을 갖는 함수다. while 루프 같은 반복문은 재귀로 대체할 수 있다
- 자바에서는 고전 방식의 재귀보다는 꼬리 재귀를 사용해야 추가적인 컴파일러 최적화를 기대할 수 있다

## Chapter19 함수형 프로그래밍 기법

학술적 지식뿐 아니라 실용적 기법을 통해 좀 더 고급적인 함수형 프로그래밍 기법을 소개

### 함수는 모든 곳에 존재한다

함수를 마치 일반값처럼 사용해서 인수로 전달하거나, 결과로 반환받거나, 자료구조에 저장할 수 있는 것을 함수형 프로그래밍이라고 한다
- 일반값처럼 취급할 수 있는 함수를 **일급 함수**라고 한다
- 자바 8에서는 ::연산자로 **메서드 참조를** 만들거나 (int x) -> x + 1 같은 람다 표현식으로 직접 함숫값을 표현해서 메서드를 함숫값으로 사용할 수 있다

#### 고차원 함수

> Comparator<Apple> c = comparing(Apple::getWeight);

함수형 프로그래밍 커뮤니티에 따르면 Comparator.comparing처럼 다음 중 하나 이상의 동작을 수행하는 함수를 **고차원 함수**라 부른다
- 하나 이상의 함수를 인수로 받음
- 함수를 결과로 반환

**부작용과 고차원 함수**
> 부작용을 포함하는 함수를 사용하면 부정확한 결과가 발생하거나 레이스 컨디션 때문에 예상치 못한 결과가 발생할 수 있다

고차원 함수를 적용할 때도 같은 규칙이 적용된다
- 고차원 함수나 메서드를 구현할 때 어떤 인수가 전달 될 지 알 수 없으므로 인수가 부작용을 포함할 가능성을 염두에 둬야함
- 함수를 인수로 받아 사용하면서 코드가 정확히 어떤 작업을 수행하고 프로그램의 상태를 어떻게 바꿀지 예측하기 어려워짐 -> 디버깅도 어려워짐
- 인수로 전달된 함수가 어떤 부작용을 포함하게 될 지 정확하게 문서화하는 것이 좋음

#### 커링
**커링의 이론적 정의**
- 커링은 x와 y라는 두 인수를 받는 함수 f를 한 개의 인수를 받는 g라는 함수로 대체하는 기법
- f(x, y) = (g(x))(y)가 성립
함수를 모듈화하고 코드를 재사용하는 데 도움을 주는 기법

### 영속 자료구조








