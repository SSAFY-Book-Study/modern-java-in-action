# 6week issue에 대한 토론 일지

### 회의 시나리오
### 이슈
1. 안건을 올린 이유 발표
invokedynamic 부트스트랩 메서드, call site와 MethodHandler

2. 안건에 대해 답변자 발표 및 설명 요약
- 람다도 익명클래스라고 생각하고 컴파일 시 익명클래스를 만들어서 처리할 수 있다고 생각할 수 있음
- 람다는 내부적으로 익명 클래스와 다른 메커니즘으로 처리
- 람다라는 것은 어떤 함수가 들어갈 지 모르기 때문에 런타임에 동적으로 함수를 참조하기 위해서 이런 복잡한 프로세스를 거친다

bootstrap method, MethodHandle, CallSite를 이용해 동적 로딩이 가능하도록 한다
-> 클래스 로더에 정적 클래스를 올리는 것이 아니라 동적으로 로딩하기 때문에 성능이 좋을 수 밖에 없다

익명클래스 vs 람다 비교
정적 바인딩과 동적 바인딩의 차이를 이해해야 한다

3. Q n A 및 회의록 기록
람다를 사용해야 하는 이유나 장점이 무엇인지 작동 원리를 이해하고자 한다면
invokedynamic를 분석해보는 것을 추천합니다

---

### 제네릭 인수 형식 추론

1. 안건을 올린 이유 발표
- 자바의 제네릭 인수의 타입을 추론하는 과정이 궁금합니다.
- 또한 자바 8 이후와 이전의 타입 추론 과정의 차이점이 있는지, 있다면 어떤 점이 있는지 궁금합니다.

2. 안건에 대해 답변자 발표 및 설명 요약
(1) Type Witness

```java
public static <T> List<T> emptyList(){
	return new ArrayList<T>();
}

// 자바 7 이전의 제네릭 메소드 호출
GenericMethods.<Integer>getList();

// 자바 8 이후 제네릭 메소드 호출
GenericMethods.getList();
```

- 자바 7 이전 : 타입을 명시하여 호출해야 함.
- 자바 8 이후 : 타입을 명시하지 않아도 됨.

** Type Witness : 타입을 명시하여 호출하는 것을 의미 **

(2) 람다와 스트림 API의 타입 추론

- 자바 8 이후 : 람다식 내부와 스트림 연산 내부에서 자동으로 타입을 추론할 수 있음.

---


### 재귀와 꼬리 호출 최적화
1. 안건을 올린 이유 발표
재귀와 꼬리 호출의 차이점과 꼬리 호출은 어떻게 최적화가 되는 걸까요?

2. 안건에 대해 답변자 발표 및 설명 요약
- 재귀 : 정지 조건을 충족할때까지 함수 호출, 스택에 계속 쌓임
  	파라미터랑 리턴 값까지 스택에 쌓이게 됨
  	stack overflow가 발생할 수 있다.
- 꼬리 호출 : 재귀와 비슷하지만, 스택에 쌓이는 것이 다름
  		꼬리호출은 재귀와 달리 연산을 하지 않고 함수 자체를 부르므로
  		스택에 함수만 쌓임
  		결과값을 반환하면 계속 전달만 해줌

3. Q n A 및 회의록 기록

스택에 계속 쌓이는데 왜 쓰는가?
-> 스택 하나만 활용, 스택 오버플로우가 발생하지 않음!
컴파일러가 어떻게 아는가?
-> 함수만 리턴하는 코드로 알게 됨



### 이슈
1. 안건을 올린 이유 발표
책에보면 가비지 컬렉터때문에 컨테이너를 구별해야한다고 하는데 가비지 컬렉터가 어떻게 제네릭을 분간하고 어떤 식으로 작동하는지 궁금합니다!
2. 안건에 대해 답변자 발표 및 설명 요약
- 컴파일 타입 체크
	- 타입을 잘못할당한 경우 ClassCastException이 발생할 수 있다.
- 명시적인 형변환을 했을때
- 런타임
  	- 제네릭을 사용했을 경우 런타임 예외가 발생할 가능성이 낮고 기본형을 사용하면 런타임 예외가 발생할 수 있다.
4. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표
- 지역 변수형 추론 var가 등장한 이유, 원래 타입을 쓰는 방향으로 변하지 않는가? 왜 거꾸로 갈까?

2. 안건에 대해 답변자 발표 및 설명 요약
   - 타입이 확정이 된 상황에서 컴파일러가 변수 추론을 충분히 할 수 있으니 코드를 작성하는 입장에서 개발자 경험을 개선하기 위함이었다.
   - 바이트코드 단계에서 타입이 명시적으로 정해져서 런타임에 따로 추론하기위한 연산이 들어가지 않습니다. ( 성능 문제 없음)

3. Q n A 및 회의록 기록
   - 다른 언어의 경우는 var를 지원하는 경우가 있으니까, 자바에서도 개발자 경험을 개선하기 위해 적용된 것 같습니다.
---


### 이슈
1. 안건을 올린 이유 발표
가비지콜렉터의 동작원리
2. 안건에 대해 답변자 발표 및 설명 요약
가비지콜렉터는 힙 영역에 선언
전제하고 있는게 객체는 생존기간에 따라 old young영역으로 나눔
minor GC -> Major Gc
사용주기에 따라 영역이동

동작원리
stop the world
모든 작업을 멈추게 됨

mark and sweep
사용하는 메모리와 사용하지 않는 메모리를 식별하여
마크 되지 않은 객체는 해제하여 메모리 확보

eden 영역
survivor영역
eden -> survivor영역으로 이동, 반복
하다가 살아남은 영역들은 old영역으로 이동하고
이것마저 차게되되면 MajorGc 수행

4. Q n A 및 회의록 기록
---
eden과 survivor 왜 1개 2개인지 
메모리 파편화를 없앨려고 2개로 나누어
메모리 효율화 작업 수행

### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

- 제네릭 관련해서 내용이 많이 나와 Type Erasure에 대해 다시 한번 알고 갔으면 좋갰습니다.

2. 안건에 대해 답변자 발표 및 설명 요약

- 이전 버전의 자바 하위 호환성과 메모리 오버헤드 방지를 위해 사용
- 런타임 시 제네릭 클래스가 바운드나 Objecgt로 변환됨
- 확장된 제네릭 타입의 다형성을 보존하기 위해 브릿지 메서드를 생성함

3. Q n A 및 회의록 기록

- 타입 소거 사용 시 메서드 오버로딩에서 에러가 생길 수 있음

---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---











