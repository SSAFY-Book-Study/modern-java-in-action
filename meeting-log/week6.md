# 6week issue에 대한 토론 일지

### 회의 시나리오
### 이슈
1. 안건을 올린 이유 발표
invokedynamic 부트스트랩 메서드, call site와 MethodHandler

2. 안건에 대해 답변자 발표 및 설명 요약
- 람다도 익명클래스라고 생각하고 컴파일 시 익명클래스를 만들어서 처리할 수 있다고 생각할 수 있음
- 람다는 내부적으로 익명 클래스와 다른 메커니즘으로 처리
- 람다라는 것은 어떤 함수가 들어갈 지 모르기 때문에 런타임에 동적으로 함수를 참조하기 위해서 이런 복잡한 프로세스를 거친다

bootstrap method, MethodHandle, CallSite를 이용해 동적 로딩이 가능하도록 한다
-> 클래스 로더에 정적 클래스를 올리는 것이 아니라 동적으로 로딩하기 때문에 성능이 좋을 수 밖에 없다

익명클래스 vs 람다 비교
정적 바인딩과 동적 바인딩의 차이를 이해해야 한다

3. Q n A 및 회의록 기록
람다를 사용해야 하는 이유나 장점이 무엇인지 작동 원리를 이해하고자 한다면
invokedynamic를 분석해보는 것을 추천합니다

---

### 제네릭 인수 형식 추론

1. 안건을 올린 이유 발표
- 자바의 제네릭 인수의 타입을 추론하는 과정이 궁금합니다.
- 또한 자바 8 이후와 이전의 타입 추론 과정의 차이점이 있는지, 있다면 어떤 점이 있는지 궁금합니다.

2. 안건에 대해 답변자 발표 및 설명 요약
(1) Type Witness

```java
public static <T> List<T> emptyList(){
	return new ArrayList<T>();
}

// 자바 7 이전의 제네릭 메소드 호출
GenericMethods.<Integer>getList();

// 자바 8 이후 제네릭 메소드 호출
GenericMethods.getList();
```

- 자바 7 이전 : 타입을 명시하여 호출해야 함.
- 자바 8 이후 : 타입을 명시하지 않아도 됨.

** Type Witness : 타입을 명시하여 호출하는 것을 의미 **

(2) 람다와 스트림 API의 타입 추론

- 자바 8 이후 : 람다식 내부와 스트림 연산 내부에서 자동으로 타입을 추론할 수 있음.

---


### 재귀와 꼬리 호출 최적화
1. 안건을 올린 이유 발표
재귀와 꼬리 호출의 차이점과 꼬리 호출은 어떻게 최적화가 되는 걸까요?

2. 안건에 대해 답변자 발표 및 설명 요약
- 재귀 : 정지 조건을 충족할때까지 함수 호출, 스택에 계속 쌓임
  	파라미터랑 리턴 값까지 스택에 쌓이게 됨
  	stack overflow가 발생할 수 있다.
- 꼬리 호출 : 재귀와 비슷하지만, 스택에 쌓이는 것이 다름
  		꼬리호출은 재귀와 달리 연산을 하지 않고 함수 자체를 부르므로
  		스택에 함수만 쌓임
  		결과값을 반환하면 계속 전달만 해줌

3. Q n A 및 회의록 기록

스택에 계속 쌓이는데 왜 쓰는가?
-> 스택 하나만 활용, 스택 오버플로우가 발생하지 않음!
컴파일러가 어떻게 아는가?
-> 함수만 리턴하는 코드로 알게 됨



### 이슈
1. 안건을 올린 이유 발표
책에보면 가비지 컬렉터때문에 컨테이너를 구별해야한다고 하는데 가비지 컬렉터가 어떻게 제네릭을 분간하고 어떤 식으로 작동하는지 궁금합니다!
2. 안건에 대해 답변자 발표 및 설명 요약
- 컴파일 타입 체크
	- 타입을 잘못할당한 경우 ClassCastException이 발생할 수 있다.
- 명시적인 형변환을 했을때
- 런타임
  	- 제네릭을 사용했을 경우 런타임 예외가 발생할 가능성이 낮고 기본형을 사용하면 런타임 예외가 발생할 수 있다.
4. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표
- 지역 변수형 추론 var가 등장한 이유, 원래 타입을 쓰는 방향으로 변하지 않는가? 왜 거꾸로 갈까?

2. 안건에 대해 답변자 발표 및 설명 요약
   - 타입이 확정이 된 상황에서 컴파일러가 변수 추론을 충분히 할 수 있으니 코드를 작성하는 입장에서 개발자 경험을 개선하기 위함이었다.
   - 바이트코드 단계에서 타입이 명시적으로 정해져서 런타임에 따로 추론하기위한 연산이 들어가지 않습니다. ( 성능 문제 없음)

3. Q n A 및 회의록 기록
   - 다른 언어의 경우는 var를 지원하는 경우가 있으니까, 자바에서도 개발자 경험을 개선하기 위해 적용된 것 같습니다.
---


### 이슈
1. 안건을 올린 이유 발표
가비지콜렉터의 동작원리
2. 안건에 대해 답변자 발표 및 설명 요약
가비지콜렉터는 힙 영역에 선언
전제하고 있는게 객체는 생존기간에 따라 old young영역으로 나눔
minor GC -> Major Gc
사용주기에 따라 영역이동

동작원리
stop the world
모든 작업을 멈추게 됨

mark and sweep
사용하는 메모리와 사용하지 않는 메모리를 식별하여
마크 되지 않은 객체는 해제하여 메모리 확보

eden 영역
survivor영역
eden -> survivor영역으로 이동, 반복
하다가 살아남은 영역들은 old영역으로 이동하고
이것마저 차게되되면 MajorGc 수행

4. Q n A 및 회의록 기록
---
eden과 survivor 왜 1개 2개인지 
메모리 파편화를 없앨려고 2개로 나누어
메모리 효율화 작업 수행

### 이슈
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록
---


### 이슈
1. 안건을 올린 이유 발표

- 제네릭 관련해서 내용이 많이 나와 Type Erasure에 대해 다시 한번 알고 갔으면 좋갰습니다.

2. 안건에 대해 답변자 발표 및 설명 요약

- 이전 버전의 자바 하위 호환성과 메모리 오버헤드 방지를 위해 사용
- 런타임 시 제네릭 클래스가 바운드나 Objecgt로 변환됨
- 확장된 제네릭 타입의 다형성을 보존하기 위해 브릿지 메서드를 생성함

3. Q n A 및 회의록 기록

- 타입 소거 사용 시 메서드 오버로딩에서 에러가 생길 수 있음

---


### 이슈
1. 안건을 올린 이유 발표

  jvm에서 돌아가는 다른 언어들도 있다는 것이 신기하고 구조가 궁금하였습니다.

2. 안건에 대해 답변자 발표 및 설명 요약

  jvm과 vm은 같은 의미인가? 라는 의도의 질문에서의 답변을 보면
  vm: 하드웨어 시스템 전체를 가상화 한 것이고
  jvm: 프로세서만 가상화 한 것입니다.
  
  jvm은 vm과 추상 시스템을 제공한다는 점만 같고 vm과는 완전히 다르다고 이해하면 됩니다.
  jvm은 OS에 구애받지 않기 위해 존재하는 것

- 구성요소
  클래스 로더 :  동적 로딩 제공. 클래스를 사용하려고 하면 바이트코드를 통해 메모리에 로드.
  	과정은 로딩 링킹 이니셜라이즈. 최상위 -> 하위 클래스 로더 순으로 돌면서 클래스를 찾는다. 못찾으면 클래스 낫 파운드 exception 등 발생 가능.
  	링킹은 현재 구조가 자바 언어 명세서와 맞는지 검사.
  	이니셜라이제이션. 선언해놓은 값으로 초기화해주는 기능.
  	할당은
  런타임 ?? : . 메모리 최적화 담당. 바이트 코드를 기계어로 변환. 
  	- 메서드 에리어 : 스태틱 코드 상수풀 등등을 메서드 에리어에 저장.
  	- 힙 에리어 : 사용하려는 객체들. 가비지컬렉션으로 관리
  	- 스택 에리어 : jvm에서 새로운 스레드 -> 별도의 스택 프레임 생성
  	- pc 레지스터 : 스레드마다 생성. 프로그램 카운터(다음명령어위치저장)
  	- ? : 네이티브 메서드 사용에 따라 별도의 공간 생성.
		네이티브 메서드 인터페이스 JNI : c, c++ 패키지 등을 호출하여 사용하기 위해. 이들을 저장한 라이브러리가 네이티브 메서드 라이브러리. JNI를 통해 가져올 수 있다.
  익스큐션 엔진 : 실행을 시키는 엔진
	인터프리터 : 한 줄씩 변환하여 명령어 실행.
	JIT 컴파일러 : 반복 코드 감지 하면 핫 스팟 부분이라고 한다. 이 부분을 기계 코드로 변환하는 과정을 거침. 캐싱을 통해 이를 보관. 이후 적절한 시간 이를 빠르게 수행
	가비지 컬렉터 : 스탑 워드. 마크 스윕

3. Q n A 및 회의록 기록
---

## 이슈

1. 안건을 올린 이유 발표

CPP에서는 데이터형은 Generic Type이 아닌 Primitive Type으로 쓰는데 이와 다르게 JAVA는 반대로 쓰는 이유와 반대로 썼을 때의 특징에 대해서 궁금합니다.

2. 안건에 대해 답변자 발표 및 설명 요약

첫번쨰로, 데이터형을 Primitive Type이 아닌 Generic Type를 쓰는 이유는 하위 호환성에 의의가 있다. 하위 호환성으로 인해 이전에 제네릭으로 사용되는 모든 것들은 Object로 변환할 수 있어야 하지만 primitive type은 그렇지 않기 때문에 제네릭을 컴파일 타임에 변환할 수 있도록 데이터형을 객체형으로 사용한다. 

두번째로, Call by value 형태의 호출 방식을 가지는 JAVA와 다르게 CPP는 Call by reference 형태의 호출 방식으로 메모리에 접근이 가능하기 때문에 Primitive Type을 써도 무관하다. 즉, Java도 포인터가 없기 때문에 Call by referce 형태의 호출을 하는 것처럼 사용하기 위해 Generic Type형태로 사용한다.

3. Q n A 및 회의록 기록
