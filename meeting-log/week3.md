# 3week issue에 대한 토론 일지
## 회의 시나리오
## 이슈 []
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록

---

## 이슈 [메서드 참조를 디버깅 할 때의 스택 트레이스]
1. 안건을 올린 이유 발표
- 람다의 스택 트레이스등이 

2. 안건에 대해 답변자 발표 및 설명 요약
- 참조 사용시 스택 트레이스에서 아무런 연고도 없는 숫자가 나타나고, 메서드 참조에서 람다를 사용했을 때보다 더 복잡한 스택트레이스가 발생합니다.
- 람다는 익명함수로서 이름이 없습니다. 이를 컴파일 할 때 컴파일러가 해당 이름이 없어, 이 부분에 임의의 숫자값을 자동으로 생성해서 사용합니다.
- 이런 숫자들은 결론적으로 의미가 없는 숫자들입니다.
- 스택트레이스에서 람다 표현식을 사용했을때 출력에서 앞부분은 클래스, 뒷부분은 람다사용을 알리고 메인은 메인에서 사용됐음을, 마지막 숫자는 임의생성한 숫자임을 나타냅니다.
- 람다를 사용했을 때의 스택 트레이스는 이해하기가 직관적인 정보를 얻기 힘다는 점을 염두하면 좋을 것 같습니다.

3. Q n A 및 회의록 기록

---

## 이슈 [ConcurrentHashMap과 HashMap]
1. 안건을 올린 이유 발표

HashMap과 ConcurrentHashMap을 책에서 소개하고 있는데 왜 ConcurrentHashMap을 사용하는지 모르겠어서 이슈로 올렸습니다

2. 안건에 대해 답변자 발표 및 설명 요약

어떤점이 다르고 어떤 상황에 적합?

HashMap
- K, V null 허용
- Thread safe하지 않다
- 동기화 과정이 없음
- 동시성 문제를 방지하기 위해 Iterator 사용
  - 동시성 문제를 해결하는 용도가 아님
- 동기화가 없어 속도가 빠름

ConcurrentHashMap
- K, V null 허용x
- Thread safe하다
- 추가적인 수정, 삭제에 동기화
- 병렬 처리에서 수정 전, 후의 값을 보장하지 못함
- sync 블럭을 사용해 각 엔트리별로 동기화

3. Q n A 및 회의록 기록

HashMap은 신뢰성과 안정성이 낮은 대신 수정 속도가 빠르다는 전제는 멀티스레드 환경에서 신뢰성과 안정성이 낮다는 의미?
- 네

Thread safe한데 왜 수정과 읽기 상황에서 왜 수정 후를 보장하지 못하나요?
- 수정과 삭제에 락을 걸긴 하지만 읽는 것에 대해 락을 거는 것이 아니어서 수정 전에 읽는지 수정 후에 읽는지는 장담할 수 없음

ConcurrentModificationExption 대체 방법?
- 싱글스레드에서는 잘 못 사용했기 때문에 발생한 것
---


## 이슈 [리팩터링의 방법]
1. 안건을 올린 이유 발표
- 코드의 크기가 커지면서 코드 관리(유지보수)가 힘들어지고 있습니다. 이러한 경우, 객체 간의 관계를 관리하기 복잡해질 뿐 아니라 결국에는 어디서부터 건드려야 할 지 모를 수도 있습니다. 이에 따라 코드를 관리하고 유지보수를 쉽게 하는 목표를 이루고자 리팩터링에 대해 질문하게 되었습니다.

2. 안건에 대해 답변자 발표 및 설명 요약
- 컬렉션 캡슐화 하기
  getter -> 원본을 반환, setter -> 원본을 직접 수정할 수 있음, 리팩터링을 하면 add나 remove를 통해 내부 컬렉션을 수정할 수 있도록 제공해야함
  -> try & catch문에서 상황에 맞게 데이터가 어떻게 변경되는지, 호출자가 어떻게 대응할지가 중요. 컬렉션을 간접적으로 수정하도록 한다.
- 임시 변수를 질의함수로 바꾸기
  -> 데이터가 중간에 바뀌기도 하고, 사용되기도 하는 부분이 있기 때문에 변수 자체를 외부로 꺼내서 함수로 불러올 수 있음
  -> 메서드로서 불러올 수 있도록 하면 안전하게 할 수 있음
- 클래스 추출하기
  -> 클래스가 복잡해질 때, 분리해야 할 필요성이 느껴지면 객체를 빼내는 것을 생성자쪽으로 불러와서 리팩터링
- 클래스 인라인 하기
  -> 분리할 필요가 없는 클래스는 나중에 전체적으로 내부로 끌어 올 수 있어야 한다.
- 위임 숨기기
  -> 불필요하게 필요없는 객체까지 가져올 수 있음. 의존성이 높아진 코드라고 볼 수 있음. 필요한 객체를 빼낼 수 있는 메서드를 빼놓는게 더 의존성을 줄일 수 있는 방식
- 중개자 제거하기
  -> 의존성을 너무 제거하면 의존성을 허용하는 상황이 올 수도 있기 때문에 분리해서 가독성, 클라이언트 입장에서 편리하게 사용할 수 있도록 리팩터링하는 것이 좋음

3. Q n A 및 회의록 기록
- 프론트와 백엔드의 리팩터링 방법은 다른가?
  클라이언트에서는 리팩터링의 시작을 유저 입장에서 시작, 또한 관련 함수들을 잘 쓰고 있는가 백엔드에서는 관련 함수들을 잘 쓰고 있는가, 필요 없는 부분이 있는가를 중점으로 봄
  자바에서는 객체가 적절히 관리되고 있는지 검사

- 멤버변수로 그냥 빼는게 낫지 않나?
  -> 중간에 바뀌는 부분이 있기 때문이라고 함. 읽기 전용이면 상관없지만, 계속 바뀌는 변수라면 메서드로 관리를 해주는 것이 좋음.
  직접적인 상수를 쓸 때는 static final로 빼주는게 관행이므로 빼주는게 더 나음! -> 다른 개발자가 알아보기 쉽게 하기 위해서!

- 자바 클래스 vs. 리액트 클래스
  -> 리액트 클래스는 사용을 지양하고 있음,
    - 리액트 -> UI를 다루는 라이브러리, 등록된 메서드를 구현해야 하는게 개발자의 의무
    - 자바 -> 모든 사물을 객체로 바라보고, 주관적으로 필요한 부분을 구현해 나가는게 둘의 차이.

---

## 이슈 [Static Factory Method 사용 이유]
1. 안건을 올린 이유 발표
Collectors 내부 메서드들이 정적 팩토리 메서드인 이유

2. 안건에 대해 답변자 발표 및 설명 요약
팩토리 패턴
- 생성 패턴으로 많이 사용되는 디자인 패턴
- 어떤 클래스를 만드지 서브 클래스에서 정하게 하는 것
- Shape 클래스 -> 오버라이딩 해서 서브 클래스에서 객체 생성 (어떤 객체를 만들어낼지는 서브 클래스에서 결정)
- 슈퍼 클래스는 팩토리인데, 무엇을 만들어내는지 모르게함 -> 결합도를 낮춘다.

정적 팩토리 메서드 패턴의 장점
- 생성자 역할, 가독성 좋은 코드, 객체지향적 프로그래밍
- 장점1. 단순히 new로 만들어내는 것보다 객체의 역할이나 의도를 명확히 알 수 있다.
- 장점2. 캐시! : 호출 시마다 새로운 객체를 생성하는 것이 아니라 캐싱 데이터를 제공하게 됨
- 하위 자료형 반환 : 다형성을 활용한 프로그래밍을 가능하게 함

정적 팩토리 메서드 네이밍 컨벤션을 따르면 좋다.

3. Q n A 및 회의록 기록

---

## 이슈 [팩토리 메서드 구현 vs 스트림 메서드]
1. 안건을 올린 이유 발표
우선 안건을 올린 이유는 이번 단원 내용 중 대표적인 내용 중 하나가 팩토리 메서드라고 생각해서 질문 올렸습니다.

2. 안건에 대해 답변자 발표 및 설명 요약
- ArrayList.asList() vs List.of()
  - ArrayList.asList() : Arrays 내부에 구현된 이름이 똑같은 불변의 List 반환, 추가 및 삭제 X.
  - List.of() : 마찬가지로 List 내부에 구현된 불변의 List 반환.
  - Map.of(), Set.of()도 마찬가지.
 
- 불변객체 사용 이유
  - 불변객체의 장점을 이용해서 다른 컬렉션 객체로 변환이 용이.
  - 불변객체의 장점 :
    - 스레드 안정성
    - 수동 메모리 관리에 대한 필요성이 없어 코드가 간결하고 유지보수에 용이
    - 한번 객체 생성시 변경하지 않기 때문에 적은 메모리를 사용하여 성능 향상
   
- 원본데이터 변경시
  - Arrays.asList() : 얕은 복사를 하기 때문에 원본데이터 변경시 함께 변경됨.
  - List.of() : 깊은 복사를 하기 때문에 원본데이터가 변경되어도 변경되지 X.
 
- Null 여부
  - Arrays.asList() : Null이 될 수는 없지만, 얕은 복사를 하기 때문에 Null 요소는 가질 수 있음.
  - List.of() : Null이 될 수도 없고, 깊은 복사를 하기 때문에 Null 요소를 가질 수 없음.

3. Q n A 및 회의록 기록
- Q. List.of()에서 요소를 각각 모두 돌아야 하는데, 2차원 리스트는 어떻게 Null값을 직접 확인하나요?
- A. 요소를 깊이 확인하지 않고 간단히 Null을 가졌는지 여부만 확인한다.
- Q. List.of()는 불변객체인데, 왜 set으로 변경이 가능한가?
- A. List.of()를 통해 생성되는 객체의 내부에 set이 구현되어 있기 때문.

## 이슈 [불변 컬렉션의 사용 이유]
1. 안건을 올린 이유 발표
- 컬렉션은 변수를 동적으로 사용하기 위한 것으로 알고 있는데, 왜 컬렉션을 수정하지 못하는 불변 컬렉션을 사용하는 것일까?

2. 안건에 대해 답변자 발표 및 설명 요약
- 불변 컬렉션은 요소의 추가 불가. 예외 발생
- List 생성 2가지 AsList Listof가 있는데 두 개 모두 Add 할 때에는 예외 발생 AsList는 set이 가능
  1. 스레드 안정성 : 컬렉션 변경이 불가능하기에 멀티스레드 환경에서도 안전하게 사용 가능
  2. 예측성 : 변경이 불가능하기 때문에 개발자가 개발 시 코드 변경이 용이함
  3. 프로그램의 안전성 향상 : 의도적인 변경에 대한 두려움 없어짐, 컬렉션 공유 시 안정성 향상
  4. 보안적 측면 향상 : 공격자가 공격 시 컬렉션을 변경할 수 없으므로 보안적인 측면 좋음
  5. 성능적 측면 : 읽기 전용이므로 오버헤드를 피할 수 있고 캐싱으로 메모리적인 측면 좋음

3. Q n A 및 회의록 기록
- Q. 병렬 처리 시 동시성의 문제도 있지만 협업 시 개발자 간 코드 사용 및 수정 용이 향상을 위해 사용


---

## 이슈 [디자인패턴]
1. 안건을 올린 이유 발표
면접 준비를 하면서 디자인패턴을 공부한 적이 있는데 함께 공부해보고 싶어서 질문해봤습니다.

2. 안건에 대해 답변자 발표 및 설명 요약
- 디자인패턴을 사용하는 이유
	- 특정 문제를 해결할 때 코드를 형식화한 것
	- 오픈소스를 잘 이해하기 위해서
- GoF
	- 생성패턴
	객체를 생성할 때 어덯게 잘 만들것인가?
		- 싱글톤 패턴: 클래스에 인스턴스가 1개임을 보장하고 싶을때, 인스턴스 생성을 제어할 수 있고 지연로딩 도입
		- 빌더 패턴: 파라미터가 많을 때 캡슐화하고 싶을때, 주로 롬복의 빌더패턴을 사용
		- 팩토리 패턴: 생성과정을 알고 싶지 않지만  
		
	-구조패턴
	소프트웨어를 설계할 때 어떻게 더 잘 만들 수 있을까?
		- 어댑터: c->8핀 이런식으로 인터페이스를 사용할때 
		- 파사드: 로직을 캡슐화해서 따로 메서드로 빼는 방식
		- 데코레이터: 기존 객체 기능을 확장하고 싶은데 기존 객체를 사용한 타 클래스가 많을 때, 기존 객체를 필드로 사용하여 감싼 객체에 넣고싶은 추가 기능을 구현하는 방식
		- 프록시: 데코레이터와 비슷한데 직접 접근을 막음
	-행위패턴
	객체들 간의 의사소통 방식
		- 템플릿: 코드 로직이 있고 세부 요소만 바꾸고싶을때 그 요소만 따로 메소드로 빼는 방식
		- 책임 연쇄: try-catch방식처럼 책임을 다른 객체로 넘기는 방식
  
3. Q n A 및 회의록 기록

---

## 이슈 [ConcurrentModification 동작 원리]
1. 안건을 올린 이유 발표
- 코딩 시 자주 겪었지만 모르고 넘어간 exception에 대한 발생 이유와 원리를 알고싶습니다.

2. 안건에 대해 답변자 발표 및 설명 요약
- 객체의 수정 발생 시 감지해서 발생하는 익셉션이고, 멀티 쓰레드 사용 시 공유 자원에 대한 수정을 막기 위해서 만들어졌다.

- iterator 구현체에서 수정을 감지해서 발생하도록 구현되어있다.
	- Fail Fast Iterator 라고해서 동시 수정이 들어왔을 때 막기 위해서 이름이 붙여졌다.
	- iterator로 읽고 있는데 Collection에서 값을 수정하니까 동일성을 맞추기 위해 iterator에서 에러를 던집니다.

- 동작하는 원리
	- 추가나 삭제 시 MODCOUNT가 카운트 되는데, 연산 시작 시 카운트와 비교해서 달라졌다면 에러를 던집니다. 
	- 순회 수정 시는 iterator 를 만들 때의 카운트와 추가 삭제 하고 오른 카운트를 비교해서 에러가 발생하게된다.

- 수정 시에는 예외를 발생시키지 않기 때문에 이 예외처리에 동시성 처리를 의존하지 않게 사용해야 합니다. 
3. Q n A 및 회의록 기록

---
