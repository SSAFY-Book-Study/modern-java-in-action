# 1week issue에 대한 토론 일지
## 회의 시나리오
---
복붙용
## 이슈 []
1. 안건을 올린 이유 발표

2. 안건에 대해 답변자 발표 및 설명 요약

3. Q n A 및 회의록 기록

---

## 이슈 [메서드 참조를 디버깅 할 때의 스택 트레이스]
1. 안건을 올린 이유 발표
- 람다의 스택 트레이스등이 

2. 안건에 대해 답변자 발표 및 설명 요약
- 참조 사용시 스택 트레이스에서 아무런 연고도 없는 숫자가 나타나고, 메서드 참조에서 람다를 사용했을 때보다 더 복잡한 스택트레이스가 발생합니다.
- 람다는 익명함수로서 이름이 없습니다. 이를 컴파일 할 때 컴파일러가 해당 이름이 없어, 이 부분에 임의의 숫자값을 자동으로 생성해서 사용합니다.
- 이런 숫자들은 결론적으로 의미가 없는 숫자들입니다.
- 스택트레이스에서 람다 표현식을 사용했을때 출력에서 앞부분은 클래스, 뒷부분은 람다사용을 알리고 메인은 메인에서 사용됐음을, 마지막 숫자는 임의생성한 숫자임을 나타냅니다.
- 람다를 사용했을 때의 스택 트레이스는 이해하기가 직관적인 정보를 얻기 힘다는 점을 염두하면 좋을 것 같습니다.

3. Q n A 및 회의록 기록

---

## 이슈 [ConcurrentHashMap과 HashMap]
1. 안건을 올린 이유 발표

HashMap과 ConcurrentHashMap을 책에서 소개하고 있는데 왜 ConcurrentHashMap을 사용하는지 모르겠어서 이슈로 올렸습니다

2. 안건에 대해 답변자 발표 및 설명 요약

어떤점이 다르고 어떤 상황에 적합?

HashMap
- K, V null 허용
- Thread safe하지 않다
- 동기화 과정이 없음
- 동시성 문제를 방지하기 위해 Iterator 사용
  - 동시성 문제를 해결하는 용도가 아님
- 동기화가 없어 속도가 빠름

ConcurrentHashMap
- K, V null 허용x
- Thread safe하다
- 추가적인 수정, 삭제에 동기화
- 병렬 처리에서 수정 전, 후의 값을 보장하지 못함
- sync 블럭을 사용해 각 엔트리별로 동기화

3. Q n A 및 회의록 기록

HashMap은 신뢰성과 안정성이 낮은 대신 수정 속도가 빠르다는 전제는 멀티스레드 환경에서 신뢰성과 안정성이 낮다는 의미?
- 네

Thread safe한데 왜 수정과 읽기 상황에서 왜 수정 후를 보장하지 못하나요?
- 수정과 삭제에 락을 걸긴 하지만 읽는 것에 대해 락을 거는 것이 아니어서 수정 전에 읽는지 수정 후에 읽는지는 장담할 수 없음

ConcurrentModificationExption 대체 방법?
- 싱글스레드에서는 잘 못 사용했기 때문에 발생한 것
---
